<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis数据安全与性能保障]]></title>
    <url>%2F2018%2F01%2F29%2Fredis%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BF%9D%E9%9A%9C%2F</url>
    <content type="text"><![CDATA[一.持久化1. 快照： 将存在于某一时刻的所有数据都写入硬盘里面方法： 客户端通过向redis发送bgsave命令（创建子进程） 客户端通过向redis发送save命令，但是会阻塞其他命令，所以只有内存不够，或者不怕阻塞的时候才可以用。但是不要创建子进程，不会导致redis停顿，并且由于没有子进程抢资源所以比bgsave快。 设置了save选项：比如 save 60 10000，表示从最近一次创建快照之后开始算起，当有60s内有10000次写入的时候就会触发bgsave命令，可以有多个save配置，任意一个满足即可。 通过shutdown接收到关闭请求时，或者接收到标准的term信号，执行save命令 当一个redis服务器连接另一个redis服务器，想对方发送sync时，若主服务器没执行bgsave，或者并非刚刚执行完，那么主服务器就会执行bgsave。 缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。TIPS: 将开发环境尽可能的模拟生产环境以得到正确的快照生成速率配置。 2. AOF：在执行写命令时，将被执行的写命令复制到硬盘里面使用appendonlyyes配置选项打开，下图是appendfsync配置选项。 选项目 同步频率 always 每个写操作都要同步写入，严重降低redis速度损耗硬盘寿命 everysec 每秒执行一次，将多个写入同步，墙裂推荐 no 让os决定，不稳定，不知道会丢失多少数据 自动配置aof重写： auto-aof-rewrite-percentage 100 auto-aof-rrewrite-min-size 64当启用aof持久化之后，当aof文件体积大于64mb并且体积比上一次大了100%，就会执行bgrewriteaof命令。 缺点：1.aof文件过大，2. 文件过大导致还原事件过长。但是可以对其进行重写压缩。 二. 复制就像之前所说当一个从服务器连接一个主服务器的时候，主服务器会创建一个快照文件并将其发送到从服务器。 在配置中包含slaveof host port选项指定主服务器，启动时候会先执行aof或者快照文件。 也可以通过发送flaveof no one命令来终止复制操作，通过slaveof host port命令来开始复制一个主服务器，会直接执行下面的连接操作。 步骤 主服务器操作 从服务器操作 1 （等待命令） 连接主服务器，发送sync命令 2 开始执行bgsave，并使用缓冲区记录bgsave之后执行的所有写命令 根据配置选项决定使用现有数据处理客户端请求还是返回错误 3 Bgsave执行完毕，向从服务器发快照，并在发送期间继续用缓冲区记录写命令 丢弃所有旧数据，载入快照文件 4 快照发送完毕，向从服务器发送缓冲区里的写命令 完成快照解释，开始接受命令 5 缓冲区存储的写命令发送完毕：从现在起每执行一个写命令都发给从服务器 执行主服务器发来的所有存储在缓冲区里的写；并接受执行主服务器发来的写命令 三. 处理故障系统验证快照和aof文件 redis-check-aof redis-check-dump 检查aof和快照文件的状态，在有需要的情况下对aof文件进行修复。 更换新的故障主服务器假设A为主服务器，B为从服务器，当机器A发生故障的时候，更换服务器的步骤如下：首先向机器B发送一个save命令，将这个快照文件发送给机器C，在C上启动Redis，让B成为C的从服务器。 将从服务器升级为主服务器将从服务器升级为主服务器，为升级后的主服务器创建从服务器。 redis事务四. 事务multi: 标记一个事务块的开始。 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。 exec: 执行所有事务块内的命令。 假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。 redis的事务包裹在multi命令和exec命令之中，在jedis中通过如下实现12345678910111213141516171819202122232425262728293031323334 public class RedisJava extends Thread&#123; static Response&lt;String&gt; ret; Jedis conn = new Jedis("localhost"); @Override public void run() &#123; Transaction t = conn.multi(); t.incr("notrans:"); Response&lt;String&gt; result1 = t.get("notrans:"); try &#123; Thread.sleep(1L); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; t.incrBy("notrans:", -1); t.exec(); String foolbar = result1.get(); System.out.println(foolbar); &#125; public static void main(String[] args) &#123; Jedis conn = new Jedis("localhost"); Thread t1 = new RedisJava(); Thread t2 = new RedisJava(); Thread t3 = new RedisJava(); t1.start(); t2.start(); t3.start(); &#125;&#125; wathc：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 unwatch：取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。 discard :取消事务，放弃执行事务块内的所有命令。取消watch，清空任务队列。如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。 一个简单的商品买卖demo如下： key type inventory：id set market zset user:id hash 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public boolean listItem( Jedis conn, String itemId, String sellerId, double price) &#123; String inventory = "inventory:" + sellerId; String item = itemId + '.' + sellerId; long end = System.currentTimeMillis() + 5000; while (System.currentTimeMillis() &lt; end) &#123; conn.watch(inventory); if (!conn.sismember(inventory, itemId))&#123; conn.unwatch(); return false; &#125; Transaction trans = conn.multi(); trans.zadd("market:", price, item); trans.srem(inventory, itemId); List&lt;Object&gt; results = trans.exec(); // null response indicates that the transaction was aborted due to // the watched key changing. if (results == null)&#123; continue; &#125; return true; &#125; return false; &#125;public boolean purchaseItem( Jedis conn, String buyerId, String itemId, String sellerId, double lprice) &#123; String buyer = "users:" + buyerId; String seller = "users:" + sellerId; String item = itemId + '.' + sellerId; String inventory = "inventory:" + buyerId; long end = System.currentTimeMillis() + 10000; while (System.currentTimeMillis() &lt; end)&#123; conn.watch("market:", buyer); double price = conn.zscore("market:", item); double funds = Double.parseDouble(conn.hget(buyer, "funds")); if (price != lprice || price &gt; funds)&#123; conn.unwatch(); return false; &#125; Transaction trans = conn.multi(); trans.hincrBy(seller, "funds", (int)price); trans.hincrBy(buyer, "funds", (int)-price); trans.sadd(inventory, itemId); trans.zrem("market:", item); List&lt;Object&gt; results = trans.exec(); // null response indicates that the transaction was aborted due to // the watched key changing. if (results == null)&#123; continue; &#125; return true; &#125; 总结：相比于一般关系型数据库的悲观锁，redis的事务是典型的乐观锁，没有对事务进行封锁，以避免客户端运行过慢造成长时间的阻塞 非事务型流水线使用流水线，减少通信次数提高性能，以jedis为例，对比使用和没使用流水线的函数方法调用次数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void updateTokenPipeline(Jedis conn, String token, String user, String item) &#123; long timestamp = System.currentTimeMillis() / 1000; Pipeline pipe = conn.pipelined(); pipe.multi(); pipe.hset("login:", token, user); pipe.zadd("recent:", timestamp, token); if (item != null)&#123; pipe.zadd("viewed:" + token, timestamp, item); pipe.zremrangeByRank("viewed:" + token, 0, -26); pipe.zincrby("viewed:", -1, item); &#125; pipe.exec();&#125;//对比没有使用流水线的方法public void updateToken(Jedis conn, String token, String user, String item) &#123; long timestamp = System.currentTimeMillis() / 1000; conn.hset("login:", token, user); conn.zadd("recent:", timestamp, token); if (item != null) &#123; conn.zadd("viewed:" + token, timestamp, item); conn.zremrangeByRank("viewed:" + token, 0, -26); conn.zincrby("viewed:", -1, item); &#125;&#125;//测试函数如下 public void benchmarkUpdateToken(Jedis conn, int duration) &#123; try&#123; @SuppressWarnings("rawtypes") Class[] args = new Class[]&#123; Jedis.class, String.class, String.class, String.class&#125;; Method[] methods = new Method[]&#123; this.getClass().getDeclaredMethod("updateToken", args), this.getClass().getDeclaredMethod("updateTokenPipeline", args), &#125;; for (Method method : methods)&#123; int count = 0; long start = System.currentTimeMillis(); long end = start + (duration * 1000); while (System.currentTimeMillis() &lt; end)&#123; count++; method.invoke(this, conn, "token", "user", "item"); &#125; long delta = System.currentTimeMillis() - start; System.out.println( method.getName() + ' ' + count + ' ' + (delta / 1000) + ' ' + (count / (delta / 1000))); &#125; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;&#125; 运行结果如图所示，在本地运行性能提升大概17.8倍。 tips：可以使用redis-benchmark工具进行性能测试。 五. References 《Redis实战》]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nosql</tag>
        <tag>持久化</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探线程池]]></title>
    <url>%2F2018%2F01%2F17%2F%E5%88%9D%E6%8E%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[概述这几天准备深入学习有关并发的知识，所以先简单复习了一下JDK自带的并发包，其中首先比较重要的一个就是线程池了。 为什么不无限的创造线程？主要基于以下几个原因： 线程生命周期的开销非常高 资源消耗 稳定性 所谓物极必反，线程的创建和销毁和需要一定的时间，如果所创建的线程工作时间还不如创建销毁的时间长那是得不偿失的，并且当线程创建过多也会对内存造成一定的负担甚至溢出，并且对GC也是极大的消耗，由于存在一定数额的活跃线程也提高了响应性。 线程池根据《阿里巴巴Java开发手册》中对线程创建的要求 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程 由此可见，在正式生产环境中，线程池是唯一的创建线程的方法。而JDK对线程池也有强大的支持。 根据《手册》中的另一点要求 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下：1） FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。2） CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM 虽然Executor为我们提供了很多方便的工厂方法，比如newSingleThreadExecutor(),也有Executors为我们很好的实现了这些工厂方法，但是手动实现ThreadPoolExecutor能让我们对线程池有更深的了解和控制。所以接下来让我们来介绍一下ThreadPoolExecutor这个类。 原理一个最常见的ThreadPoolExecutor构造函数如下 1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize： 活动线程数 maximumPoolSize： 线程池上限 keepAliveTime： 当线程池中线程数超过corePoolSize后，完成工作后的线程存活时间 unit： 单位其余的几个参数我们会在后面着重介绍。 这里介绍一下ThreadPoolExecutor的核心工作原理 123456789101112131415int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); workderCountOf()获得当前线程池线程总数，若小于corePoolSize，则直接将任务通过addWorker()方法执行，否则在workQueue.offer()进入等待队列，若进入失败，则任务直接交给线程池，若线程池达到了maximumPoolSize则提交失败执行拒绝策略 任务队列BlockingQueue：接口，阻塞队列，数据共享通道任务队列的作用在于，当线程池中线程数达到corePoolSize的时候，接下来的任务将进入这个队列进行等待，等待执行。 简单原理服务线程（获取队列信息并处理的线程）在队列为空时进行读等待，有新的消息进入队列后自动唤醒，反之，当队列满时进行写等待直到有消息出队。 不同于常用的offer()和poll()方法，这里我们使用take()和put()方法进行读写。我们以ArrayBlockingQueue的为例子,其中包括了这几个控制对象123final ReentrantLock lick;private final Condition notEmpty;private final Condition notFull; 就拿take()来说1234567891011public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; 当队列为空时，他会在notEmpty上进行等待，在线程等待时，若有新的元素插入，线程就会被唤醒12345678910private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 常用实现 SynchronousQueue(直接提交队列): 一个零容量队列，每个插入操作要对应一个删除操作。提交的任务不会被真实保存，其实就是将新任务交给了线程执行。 ArrayBlockingQueue(有界任务队列): 这里就会用到线程池中另一个参数maximumPoolSize, 若当前线程池中线程小于corePoolSize则直接在线程池中增加线程，若大于，则加入该任务队列，若队列满则继续加入线程池，若线程池中数目多余maximumPoolSize则执行拒绝策略。 LinkedBlockingQueue(无界任务队列)：如果未指定容量，那么容量将等于 Integer.MAX_VALUE。只要插入元素不会使双端队列超出容量，每次插入后都将动态地创建链接节点。 PriorityBlockingQueue(优先任务队列)： 一个特殊的无界任务队列，前面两者都是按FIFO的顺序执行，而这个是可以按照优先级执行。拒绝策略JDK内置拒绝策略如下 AboerPolicy：直接抛出异常，组织系统正常工作。 CallerRunsPolicy: 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。（伪丢弃，但是任务提交线程性能大幅度下降） DiscardOledestPolicy:和名字一样，丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 DiscardPolicy: 丢弃无法处理的任务，不给任何处理。 异常堆栈首先给出一个例子：123456789101112131415161718192021222324252627public class Main implements Runnable&#123; int a, b; public Main(int a, int b) &#123; this.a = a; this.b = b; &#125; @Override public void run() &#123; int ret = a / b; System.out.println(ret); &#125; public static void main(String[] args) &#123; ThreadPoolExecutor pools = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 0L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) &#123; pools.submit(new Main(100, i)); &#125; &#125;&#125;/* 结果如下100335025*/ 可以发现，其中一个显然的异常除数为0不见了，我们可以通过将submit方法改为execute方法来打印部分异常信息，但是我们仍然不能发现他的调用线程在哪儿。这里我们通过扩展线程池给出一种解决办法。1234567891011121314151617181920212223242526272829303132333435363738394041424344package first_maven;import java.util.concurrent.BlockingQueue;import java.util.concurrent.Future;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Main extends ThreadPoolExecutor&#123; public Main(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); &#125; @Override public void execute(Runnable task) &#123; super.execute(wrap(task, clientTrace(), Thread.currentThread().getName())); &#125; @Override public Future&lt;?&gt; submit(Runnable task) &#123; return super.submit(wrap(task, clientTrace(), Thread.currentThread().getName())); &#125; private Exception clientTrace() &#123; return new Exception("Client stack trace"); &#125; private Runnable wrap(final Runnable task, final Exception clientStack, String clientThreadName) &#123; return new Runnable() &#123; @Override public void run() &#123; try &#123; task.run(); &#125; catch(Exception e) &#123; clientStack.printStackTrace(); System.out.println(" 1212"); throw e; &#125; &#125; &#125;; &#125;&#125; 我们通过扩展ThreadPoolExecutor，将要执行的Runnable进行包装，通过手动创建异常，获取当前主线程的调用堆栈，从而得到线程池的调用信息，并打印相应的运行异常，这样我们就可以追踪到完整的异常信息。 总结在使用多线程的时候，要通过ThreadPoolExecutor来手动创建，根据当前任务的需求分配相应的线程池大小和阻塞队列以及拒绝策略，这样才能知根知底。 五. References 《实战Java高并发程序设计》 《阿里巴巴Java开发手册》]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2018%2F01%2F13%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这两天正在看关于多线程的一些内容，看到线程池的时候发现它的实现使用了工厂模式，之前对工厂模式的了解不深，只是知道他是根据需要创建对象的，索性就开个支线，找了本书看了看关于工厂模式的一些知识，书中讲的也比较有意思，以下是一些心得。 概述对于设计模式来说，模式本身固然重要，但是模式设计的思想也同样很有味道，其中带来的一些OO的原则更是我们平时写代码需要注意的地方。而对于OO的设计原则其中有一个重要的思想就是将固定与变化分开，也就是简单的策略模式，将变化抽象，针对同一个接口，有各自的实现。 但是对于创建对象来说，java中只有new这一种方法，这就不可避免的要将代码写死，这又是我们不想看到的事情，由于硬编码带来的一系列拓展上的不便，使我们无法针对接口编程。就好像当我们使用集合的使用都会这么写： 1List&lt;T&gt; list = new XXXList&lt;&gt;(); 因为这种针对接口的编程给了我们更多的自由。那么有没有一种灵活的方式创建对象，那就是工厂模式，所有的工厂模式都是针对对象的创建。 一.简单工厂首先声明一下，简单工厂不是一种设计模式，只是一种习惯而已。他将动态的创建对象这一过程与固定的使用对象的代码分隔开。我们结合一个简单的例子来说：1234567891011121314151617181920212223242526272829303132333435363738394041class PizzaStore &#123; SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) &#123; this.factory = factory; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza; pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125;public class SimplePizzaFactory &#123; public Pizza createPizza(String type) &#123; Pizza pizza = null; if (type.equals("cheese")) &#123; pizza = new CheesePizza(); &#125; else if (type.equals("pepperoni")) &#123; pizza = new PepperoniPizza(); &#125; else if (type.equals("clam")) &#123; pizza = new ClamPizza(); &#125; else if (type.equals("veggie")) &#123; pizza = new VeggiePizza(); &#125; return pizza; &#125;&#125; 在这个例子中，我们所需要创建的对象是Pizza，但在这里我们通过一个factory代替了以往的new关键字来创建对象，而这样的好处也是显而易见的，在这个服务中，变化的是Pizza的种类，而处理Pizza 的流程是固定的。我们只需根据需要传入所需的factory，就能实现创建对象与使用对象的解耦。 我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。二. 工厂方法在上一个例子中，我们在PizzaStore中创建简单工厂对象，通过简单工厂创建对象，这不免让代码失去了一点弹性，让我们进一步抽象，将创建对象的方法进一步封装，形成一个抽象基类，让每个子类去各自实现自己所需的创建对象的方法。提高代码的可扩展性。下面给出例子：12345678910111213141516171819202122232425262728abstract class PizzaStore &#123; abstract Pizza createPizza(String item); public Pizza orderPizza(String type) &#123; Pizza pizza = createPizza(type); System.out.println("--- Making a " + pizza.getName() + " ---"); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125;public class ChicagoPizzaStore extends PizzaStore &#123; Pizza createPizza(String item) &#123; if (item.equals("cheese")) &#123; return new ChicagoStyleCheesePizza(); &#125; else if (item.equals("veggie")) &#123; return new ChicagoStyleVeggiePizza(); &#125; else if (item.equals("clam")) &#123; return new ChicagoStyleClamPizza(); &#125; else if (item.equals("pepperoni")) &#123; return new ChicagoStylePepperoniPizza(); &#125; else return null; &#125;&#125; 在上面的代码中，对象的创建只给出了一个抽象方法，而具体的实现，则有子类自由选择决定，这样极大的丰富了代码的选择性和扩展性。基类实际上并不知道他持有的是什么对象，他主要负责持有对象后的一系列固定流程操作。 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 对比工厂方法和简单工厂原本有一个对象负责所有具体类的实例化，而在工厂方法中则由一些子类来负责实例化。工厂方法用来处理对象的创建，并将行为封装在子类，这样基类的代码就和子类的对象创建完全解耦。 三. 抽象工厂当你需要创建的对象也依赖了一系列可变对象，那么就需要工厂模式中的最后一种方式–抽象工厂。我们首先给出抽象工厂的定义： 提供一个借口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。让我们再用Pizza来举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ChicagoPizzaStore extends PizzaStore &#123; protected Pizza createPizza(String item) &#123; Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new ChicagoPizzaIngredientFactory(); if (item.equals("cheese")) &#123; pizza = new CheesePizza(ingredientFactory); pizza.setName("Chicago Style Cheese Pizza"); &#125; else if (item.equals("veggie")) &#123; pizza = new VeggiePizza(ingredientFactory); pizza.setName("Chicago Style Veggie Pizza"); &#125; else if (item.equals("clam")) &#123; pizza = new ClamPizza(ingredientFactory); pizza.setName("Chicago Style Clam Pizza"); &#125; else if (item.equals("pepperoni")) &#123; pizza = new PepperoniPizza(ingredientFactory); pizza.setName("Chicago Style Pepperoni Pizza"); &#125; return pizza; &#125;&#125;class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory &#123; public Dough createDough() &#123; return new ThickCrustDough(); &#125; public Sauce createSauce() &#123; return new PlumTomatoSauce(); &#125; public Cheese createCheese() &#123; return new MozzarellaCheese(); &#125; public Veggies[] createVeggies() &#123; Veggies veggies[] = &#123; new BlackOlives(), new Spinach(), new Eggplant() &#125;; return veggies; &#125; public Pepperoni createPepperoni() &#123; return new SlicedPepperoni(); &#125; public Clams createClam() &#123; return new FrozenClams(); &#125;&#125; PizzaStore和之前一样，这里就不重复了，和之前不一样的是在子类的createPizza方法中，我们不是简单的返回对象，而是根据创建对象所依赖的成员的不同，也进行了“个性化定制”。 其本质上其实也是用工厂方法对依赖对象进行创建。四. 抽象工厂与抽象方法的比较 工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象，并将实例化延迟到子类。 抽象工厂使用组合，对象的创建被实现在工厂接口所暴露出来的方法中。 抽象工厂创建相关的对象家族，并让他们集合起来，而不需要依赖他们的具体类 五. References 《Head First 设计模式》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂</tag>
        <tag>OO</tag>
      </tags>
  </entry>
</search>
