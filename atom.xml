<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Be Better</title>
  
  <subtitle>厚积薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-30T07:47:45.171Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MoriatyC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis数据安全与性能保障</title>
    <link href="http://yoursite.com/2018/01/29/redis%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BF%9D%E9%9A%9C/"/>
    <id>http://yoursite.com/2018/01/29/redis数据安全与性能保障/</id>
    <published>2018-01-29T13:03:54.000Z</published>
    <updated>2018-01-30T07:47:45.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-持久化"><a href="#一-持久化" class="headerlink" title="一.持久化"></a>一.持久化</h2><h4 id="1-快照：-将存在于某一时刻的所有数据都写入硬盘里面"><a href="#1-快照：-将存在于某一时刻的所有数据都写入硬盘里面" class="headerlink" title="1. 快照： 将存在于某一时刻的所有数据都写入硬盘里面"></a>1. 快照： 将存在于某一时刻的所有数据都写入硬盘里面</h4><h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><ol><li>客户端通过向redis发送bgsave命令（创建子进程）</li><li>客户端通过向redis发送save命令，但是会<strong>阻塞</strong>其他命令，所以只有内存不够，或者不怕阻塞的时候才可以用。但是不要创建子进程，不会导致redis停顿，并且由于没有子进程抢资源所以比bgsave快。</li><li>设置了save选项：比如 save 60 10000，表示从最近一次创建快照之后开始算起，当有60s内有10000次写入的时候就会触发bgsave命令，可以有多个save配置，任意一个满足即可。</li><li>通过shutdown接收到关闭请求时，或者接收到标准的term信号，执行save命令</li><li>当一个redis服务器连接另一个redis服务器，想对方发送sync时，若主服务器没执行bgsave，或者并非刚刚执行完，那么主服务器就会执行bgsave。</li></ol><h5 id="缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。"><a href="#缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。" class="headerlink" title="缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。"></a>缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。</h5><p><strong>TIPS: 将开发环境尽可能的模拟生产环境以得到正确的快照生成速率配置。</strong></p><h4 id="2-AOF：在执行写命令时，将被执行的写命令复制到硬盘里面"><a href="#2-AOF：在执行写命令时，将被执行的写命令复制到硬盘里面" class="headerlink" title="2. AOF：在执行写命令时，将被执行的写命令复制到硬盘里面"></a>2. AOF：在执行写命令时，将被执行的写命令复制到硬盘里面</h4><p>使用appendonlyyes配置选项打开，下图是appendfsync配置选项。</p><table><thead><tr><th>选项目</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写操作都要同步写入，严重降低redis速度损耗硬盘寿命</td></tr><tr><td>everysec</td><td>每秒执行一次，将多个写入同步，墙裂推荐</td></tr><tr><td>no</td><td>让os决定，不稳定，不知道会丢失多少数据</td></tr></tbody></table><p>自动配置aof重写：</p><ul><li>auto-aof-rewrite-percentage 100</li><li>auto-aof-rrewrite-min-size 64<br>当启用aof持久化之后，当aof文件体积大于64mb并且体积比上一次大了100%，就会执行bgrewriteaof命令。</li></ul><p><strong>缺点：1.aof文件过大，2. 文件过大导致还原事件过长。<br>但是可以对其进行重写压缩。</strong></p><h2 id="二-复制"><a href="#二-复制" class="headerlink" title="二. 复制"></a>二. 复制</h2><p>就像之前所说当一个从服务器连接一个主服务器的时候，主服务器会创建一个快照文件并将其发送到从服务器。</p><p>在配置中包含slaveof host port选项指定主服务器，启动时候会先执行aof或者快照文件。</p><p>也可以通过发送flaveof no one命令来终止复制操作，通过slaveof host port命令来开始复制一个主服务器，会直接执行下面的连接操作。</p><table><thead><tr><th>步骤</th><th>主服务器操作</th><th>从服务器操作</th></tr></thead><tbody><tr><td>1</td><td>（等待命令）</td><td>连接主服务器，发送sync命令</td></tr><tr><td>2</td><td>开始执行bgsave，并使用缓冲区记录bgsave之后执行的所有写命令</td><td>根据配置选项决定使用现有数据处理客户端请求还是返回错误</td></tr><tr><td>3</td><td>Bgsave执行完毕，向从服务器发快照，并在发送期间继续用缓冲区记录写命令</td><td>丢弃所有旧数据，载入快照文件</td></tr><tr><td>4</td><td>快照发送完毕，向从服务器发送缓冲区里的写命令</td><td>完成快照解释，开始接受命令</td></tr><tr><td>5</td><td>缓冲区存储的写命令发送完毕：从现在起每执行一个写命令都发给从服务器</td><td>执行主服务器发来的所有存储在缓冲区里的写；并接受执行主服务器发来的写命令</td></tr></tbody></table><h2 id="三-处理故障系统"><a href="#三-处理故障系统" class="headerlink" title="三. 处理故障系统"></a>三. 处理故障系统</h2><h4 id="验证快照和aof文件"><a href="#验证快照和aof文件" class="headerlink" title="验证快照和aof文件"></a>验证快照和aof文件</h4><ul><li>redis-check-aof</li><li>redis-check-dump</li></ul><p>检查aof和快照文件的状态，在有需要的情况下对aof文件进行修复。</p><h4 id="更换新的故障主服务器"><a href="#更换新的故障主服务器" class="headerlink" title="更换新的故障主服务器"></a>更换新的故障主服务器</h4><p>假设A为主服务器，B为从服务器，当机器A发生故障的时候，更换服务器的步骤如下：<br>首先向机器B发送一个save命令，将这个快照文件发送给机器C，在C上启动Redis，让B成为C的从服务器。</p><h4 id="将从服务器升级为主服务器"><a href="#将从服务器升级为主服务器" class="headerlink" title="将从服务器升级为主服务器"></a>将从服务器升级为主服务器</h4><p>将从服务器升级为主服务器，为升级后的主服务器创建从服务器。</p><h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><h2 id="四-事务"><a href="#四-事务" class="headerlink" title="四. 事务"></a>四. 事务</h2><p>multi: 标记一个事务块的开始。</p><p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p><p>exec: 执行所有事务块内的命令。</p><p>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p><p>redis的事务包裹在multi命令和exec命令之中，在jedis中通过如下实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisJava</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Response&lt;String&gt; ret;</span><br><span class="line">    Jedis conn = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Transaction t = conn.multi();</span><br><span class="line">        t.incr(<span class="string">"notrans:"</span>);</span><br><span class="line">        Response&lt;String&gt; result1 = t.get(<span class="string">"notrans:"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.incrBy(<span class="string">"notrans:"</span>, -<span class="number">1</span>);</span><br><span class="line">        t.exec();</span><br><span class="line">        String foolbar = result1.get();       </span><br><span class="line">        System.out.println(foolbar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> RedisJava();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> RedisJava();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> RedisJava();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>wathc：<br>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li><li>unwatch：<br>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。<br>的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</li><li>discard :取消事务，放弃执行事务块内的所有命令。取消watch，清空任务队列。<br>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</li></ul><p>一个简单的商品买卖demo如下：</p><table><thead><tr><th>key</th><th>type</th></tr></thead><tbody><tr><td>inventory：id</td><td>set</td></tr><tr><td>market</td><td>zset</td></tr><tr><td>user:id</td><td>hash</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">listItem</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Jedis conn, String itemId, String sellerId, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       String inventory = <span class="string">"inventory:"</span> + sellerId;</span><br><span class="line">       String item = itemId + <span class="string">'.'</span> + sellerId;</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis() + <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (System.currentTimeMillis() &lt; end) &#123;</span><br><span class="line">           conn.watch(inventory);</span><br><span class="line">           <span class="keyword">if</span> (!conn.sismember(inventory, itemId))&#123;</span><br><span class="line">               conn.unwatch();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Transaction trans = conn.multi();</span><br><span class="line">           trans.zadd(<span class="string">"market:"</span>, price, item);</span><br><span class="line">           trans.srem(inventory, itemId);</span><br><span class="line">           List&lt;Object&gt; results = trans.exec();</span><br><span class="line">           <span class="comment">// null response indicates that the transaction was aborted due to</span></span><br><span class="line">           <span class="comment">// the watched key changing.</span></span><br><span class="line">           <span class="keyword">if</span> (results == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchaseItem</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Jedis conn, String buyerId, String itemId, String sellerId, <span class="keyword">double</span> lprice)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       String buyer = <span class="string">"users:"</span> + buyerId;</span><br><span class="line">       String seller = <span class="string">"users:"</span> + sellerId;</span><br><span class="line">       String item = itemId + <span class="string">'.'</span> + sellerId;</span><br><span class="line">       String inventory = <span class="string">"inventory:"</span> + buyerId;</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis() + <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (System.currentTimeMillis() &lt; end)&#123;</span><br><span class="line">           conn.watch(<span class="string">"market:"</span>, buyer);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">double</span> price = conn.zscore(<span class="string">"market:"</span>, item);</span><br><span class="line">           <span class="keyword">double</span> funds = Double.parseDouble(conn.hget(buyer, <span class="string">"funds"</span>));</span><br><span class="line">           <span class="keyword">if</span> (price != lprice || price &gt; funds)&#123;</span><br><span class="line">               conn.unwatch();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Transaction trans = conn.multi();</span><br><span class="line">           trans.hincrBy(seller, <span class="string">"funds"</span>, (<span class="keyword">int</span>)price);</span><br><span class="line">           trans.hincrBy(buyer, <span class="string">"funds"</span>, (<span class="keyword">int</span>)-price);</span><br><span class="line">           trans.sadd(inventory, itemId);</span><br><span class="line">           trans.zrem(<span class="string">"market:"</span>, item);</span><br><span class="line">           List&lt;Object&gt; results = trans.exec();</span><br><span class="line">           <span class="comment">// null response indicates that the transaction was aborted due to</span></span><br><span class="line">           <span class="comment">// the watched key changing.</span></span><br><span class="line">           <span class="keyword">if</span> (results == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>总结：相比于一般关系型数据库的悲观锁，redis的事务是典型的乐观锁，没有对事务进行封锁，以避免客户端运行过慢造成长时间的阻塞</p><h4 id="非事务型流水线"><a href="#非事务型流水线" class="headerlink" title="非事务型流水线"></a>非事务型流水线</h4><p>使用流水线，减少通信次数提高性能，以jedis为例，对比使用和没使用流水线的函数方法调用次数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTokenPipeline</span><span class="params">(Jedis conn, String token, String user, String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    Pipeline pipe = conn.pipelined();</span><br><span class="line">    pipe.multi();</span><br><span class="line">    pipe.hset(<span class="string">"login:"</span>, token, user);</span><br><span class="line">    pipe.zadd(<span class="string">"recent:"</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pipe.zadd(<span class="string">"viewed:"</span> + token, timestamp, item);</span><br><span class="line">        pipe.zremrangeByRank(<span class="string">"viewed:"</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        pipe.zincrby(<span class="string">"viewed:"</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">    pipe.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对比没有使用流水线的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateToken</span><span class="params">(Jedis conn, String token, String user, String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    conn.hset(<span class="string">"login:"</span>, token, user);</span><br><span class="line">    conn.zadd(<span class="string">"recent:"</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conn.zadd(<span class="string">"viewed:"</span> + token, timestamp, item);</span><br><span class="line">        conn.zremrangeByRank(<span class="string">"viewed:"</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        conn.zincrby(<span class="string">"viewed:"</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试函数如下</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchmarkUpdateToken</span><span class="params">(Jedis conn, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">        Class[] args = <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">            Jedis.class, String.class, String.class, String.class&#125;;</span><br><span class="line">        Method[] methods = <span class="keyword">new</span> Method[]&#123;</span><br><span class="line">            <span class="keyword">this</span>.getClass().getDeclaredMethod(<span class="string">"updateToken"</span>, args),</span><br><span class="line">            <span class="keyword">this</span>.getClass().getDeclaredMethod(<span class="string">"updateTokenPipeline"</span>, args),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> end = start + (duration * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; end)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                method.invoke(<span class="keyword">this</span>, conn, <span class="string">"token"</span>, <span class="string">"user"</span>, <span class="string">"item"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> delta = System.currentTimeMillis() - start;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    method.getName() + <span class="string">' '</span> +</span><br><span class="line">                    count + <span class="string">' '</span> +</span><br><span class="line">                    (delta / <span class="number">1000</span>) + <span class="string">' '</span> +</span><br><span class="line">                    (count / (delta / <span class="number">1000</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如图所示，在本地运行性能提升大概17.8倍。<img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/benchmark.png" alt=""></p><p>tips：可以使用redis-benchmark工具进行性能测试。</p><h2 id="五-References"><a href="#五-References" class="headerlink" title="五. References"></a>五. References</h2><blockquote><p>《Redis实战》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-持久化&quot;&gt;&lt;a href=&quot;#一-持久化&quot; class=&quot;headerlink&quot; title=&quot;一.持久化&quot;&gt;&lt;/a&gt;一.持久化&lt;/h2&gt;&lt;h4 id=&quot;1-快照：-将存在于某一时刻的所有数据都写入硬盘里面&quot;&gt;&lt;a href=&quot;#1-快照：-将存在于某一时刻的
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="nosql" scheme="http://yoursite.com/tags/nosql/"/>
    
      <category term="持久化" scheme="http://yoursite.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>初探线程池</title>
    <link href="http://yoursite.com/2018/01/17/%E5%88%9D%E6%8E%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/01/17/初探线程池/</id>
    <published>2018-01-17T03:17:20.000Z</published>
    <updated>2018-01-30T07:47:34.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这几天准备深入学习有关并发的知识，所以先简单复习了一下JDK自带的并发包，其中首先比较重要的一个就是线程池了。</p><p>为什么不无限的创造线程？主要基于以下几个原因：</p><ol><li>线程生命周期的开销非常高</li><li>资源消耗</li><li>稳定性</li></ol><p>所谓物极必反，线程的创建和销毁和需要一定的时间，如果所创建的线程工作时间还不如创建销毁的时间长那是得不偿失的，并且当线程创建过多也会对内存造成一定的负担甚至溢出，并且对GC也是极大的消耗，由于存在一定数额的活跃线程也提高了响应性。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>根据《阿里巴巴Java开发手册》中对线程创建的要求</p><blockquote><ol><li>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</li></ol></blockquote><p>由此可见，在正式生产环境中，线程池是唯一的创建线程的方法。而JDK对线程池也有强大的支持。<img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/pool.png" alt=""></p><p>根据《手册》中的另一点要求</p><blockquote><ol><li>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明： Executors 返回的线程池对象的弊端如下：<br>1） FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>2） CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM</li></ol></blockquote><p>虽然Executor为我们提供了很多方便的工厂方法，比如<strong>newSingleThreadExecutor()</strong>,也有Executors为我们很好的实现了这些工厂方法，但是手动实现<strong>ThreadPoolExecutor</strong>能让我们对线程池有更深的了解和控制。所以接下来让我们来介绍一下<strong>ThreadPoolExecutor</strong>这个类。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个最常见的<strong>ThreadPoolExecutor</strong>构造函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize, </span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime, </span><br><span class="line">                   TimeUnit unit, </span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">                   ThreadFactory threadFactory, </span><br><span class="line">                   RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ul><li>corePoolSize： 活动线程数</li><li>maximumPoolSize： 线程池上限</li><li>keepAliveTime： 当线程池中线程数超过corePoolSize后，完成工作后的线程存活时间</li><li>unit： 单位<br>其余的几个参数我们会在后面着重介绍。</li></ul><p>这里介绍一下ThreadPoolExecutor的核心工作原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br></pre></td></tr></table></figure><p>workderCountOf()获得当前线程池线程总数，若小于corePoolSize，则直接将任务通过addWorker<br>()方法执行，否则在workQueue.offer()进入等待队列，若进入失败，则任务直接交给线程池，若线程池达到了maximumPoolSize则提交失败执行拒绝策略</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><h3 id="BlockingQueue：接口，阻塞队列，数据共享通道"><a href="#BlockingQueue：接口，阻塞队列，数据共享通道" class="headerlink" title="BlockingQueue：接口，阻塞队列，数据共享通道"></a>BlockingQueue：接口，阻塞队列，数据共享通道</h3><p>任务队列的作用在于，当线程池中线程数达到corePoolSize的时候，接下来的任务将进入这个队列进行等待，等待执行。</p><h4 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h4><p>服务线程（获取队列信息并处理的线程）在队列为空时进行读等待，有新的消息进入队列后自动唤醒，反之，当队列满时进行写等待直到有消息出队。</p><p>不同于常用的offer()和poll()方法，这里我们使用take()和put()方法进行读写。我们以ArrayBlockingQueue的为例子,其中包括了这几个控制对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lick;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure></p><p>就拿take()来说<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当队列为空时，他会在<strong>notEmpty</strong>上进行等待，<br>在线程等待时，若有新的元素插入，线程就会被唤醒<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="常用实现"><a href="#常用实现" class="headerlink" title="常用实现"></a>常用实现</h4><ul><li>SynchronousQueue(直接提交队列): 一个零容量队列，每个插入操作要对应一个删除操作。提交的任务不会被真实保存，其实就是将新任务交给了线程执行。</li><li>ArrayBlockingQueue(有界任务队列): 这里就会用到线程池中另一个参数<strong>maximumPoolSize</strong>, 若当前线程池中线程小于corePoolSize则直接在线程池中增加线程，若大于，则加入该任务队列，若队列满则继续加入线程池，若线程池中数目多余maximumPoolSize则执行拒绝策略。</li><li>LinkedBlockingQueue(无界任务队列)：如果未指定容量，那么容量将等于 Integer.MAX_VALUE。只要插入元素不会使双端队列超出容量，每次插入后都将动态地创建链接节点。</li><li>PriorityBlockingQueue(优先任务队列)： 一个特殊的无界任务队列，前面两者都是按FIFO的顺序执行，而这个是可以按照优先级执行。<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2>JDK内置拒绝策略如下</li><li>AboerPolicy(默认）：直接抛出异常，阻止系统正常工作。</li><li>CallerRunsPolicy: 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。（伪丢弃，但是任务提交线程性能大幅度下降）</li><li>DiscardOledestPolicy:和名字一样，丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy: 丢弃无法处理的任务，不给任何处理。</li></ul><h2 id="异常堆栈"><a href="#异常堆栈" class="headerlink" title="异常堆栈"></a>异常堆栈</h2><p>首先给出一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = a / b;</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor pools = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, </span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            pools.submit(<span class="keyword">new</span> Main(<span class="number">100</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果如下</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">50</span></span><br><span class="line"><span class="comment">25</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>可以发现，其中一个显然的异常除数为0不见了，我们可以通过将submit方法改为execute方法来打印部分异常信息，但是我们仍然不能发现他的调用线程在哪儿。<br>这里我们通过扩展线程池给出一种解决办法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> first_maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.execute(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"Client stack trace"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String clientThreadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                    clientStack.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">"                             1212"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通过扩展<strong>ThreadPoolExecutor</strong>，将要执行的Runnable进行包装，通过手动创建异常，获取当前主线程的调用堆栈，从而得到线程池的调用信息，并打印相应的运行异常，这样我们就可以追踪到完整的异常信息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用多线程的时候，要通过<strong>ThreadPoolExecutor</strong>来手动创建，根据当前任务的需求分配相应的线程池大小和阻塞队列以及拒绝策略，这样才能知根知底。</p><h1 id="五-References"><a href="#五-References" class="headerlink" title="五. References"></a>五. References</h1><blockquote><p>《实战Java高并发程序设计》</p><p>《阿里巴巴Java开发手册》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这几天准备深入学习有关并发的知识，所以先简单复习了一下JDK自带的并发包，其中首先比较重要的一个就是线程池了。&lt;/p&gt;
&lt;p&gt;为什么不无限的
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2018/01/13/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/13/工厂模式/</id>
    <published>2018-01-13T13:18:04.000Z</published>
    <updated>2018-01-17T08:49:29.755Z</updated>
    
    <content type="html"><![CDATA[<p>这两天正在看关于多线程的一些内容，看到线程池的时候发现它的实现使用了工厂模式，之前对工厂模式的了解不深，只是知道他是根据需要创建对象的，索性就开个支线，找了本书看了看关于工厂模式的一些知识，书中讲的也比较有意思，以下是一些心得。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于设计模式来说，模式本身固然重要，但是模式设计的思想也同样很有味道，其中带来的一些OO的原则更是我们平时写代码需要注意的地方。而对于OO的设计原则其中有一个重要的思想就是将固定与变化分开，也就是简单的策略模式，将变化抽象，针对同一个接口，有各自的实现。</p><p>但是对于创建对象来说，java中只有<strong>new</strong>这一种方法，这就不可避免的要将代码写死，这又是我们不想看到的事情，由于硬编码带来的一系列拓展上的不便，使我们无法针对<strong>接口</strong>编程。就好像当我们使用集合的使用都会这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> XXXList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因为这种针对接口的编程给了我们更多的自由。那么有没有一种灵活的方式创建对象，那就是工厂模式，<strong>所有的工厂模式都是针对对象的创建</strong>。</p><h1 id="一-简单工厂"><a href="#一-简单工厂" class="headerlink" title="一.简单工厂"></a>一.简单工厂</h1><p>首先声明一下，简单工厂不是一种设计模式，只是一种习惯而已。他将动态的创建对象这一过程与固定的使用对象的代码分隔开。我们结合一个简单的例子来说：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">SimplePizzaFactory factory;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span> </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza;</span><br><span class="line"> </span><br><span class="line">pizza = factory.createPizza(type);</span><br><span class="line"> </span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> ClamPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> VeggiePizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们所需要创建的对象是Pizza，但在这里我们通过一个<strong>factory</strong>代替了以往的<strong>new</strong>关键字来创建对象，而这样的好处也是显而易见的，在这个服务中，变化的是Pizza的种类，而处理Pizza 的流程是固定的。我们只需根据需要传入所需的factory，就能实现创建对象与使用对象的解耦。</p><h4 id="我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。"><a href="#我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。" class="headerlink" title="我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。"></a>我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。</h4><h1 id="二-工厂方法"><a href="#二-工厂方法" class="headerlink" title="二. 工厂方法"></a>二. 工厂方法</h1><p>在上一个例子中，我们在PizzaStore中创建简单工厂对象，通过简单工厂创建对象，这不免让代码失去了一点弹性，让我们进一步抽象，将创建对象的方法进一步封装，形成一个抽象基类，让每个子类去各自实现自己所需的创建对象的方法。提高代码的可扩展性。下面给出例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String item)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza = createPizza(type);</span><br><span class="line">System.out.println(<span class="string">"--- Making a "</span> + pizza.getName() + <span class="string">" ---"</span>);</span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Pizza <span class="title">createPizza</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStyleVeggiePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStyleClamPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStylePepperoniPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，对象的创建只给出了一个抽象方法，而具体的实现，则有子类自由选择决定，这样极大的丰富了代码的选择性和扩展性。基类实际上并不知道他持有的是什么对象，他主要负责持有对象后的一系列固定流程操作。</p><blockquote><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><h2 id="对比工厂方法和简单工厂"><a href="#对比工厂方法和简单工厂" class="headerlink" title="对比工厂方法和简单工厂"></a>对比工厂方法和简单工厂</h2><p>原本有一个对象负责所有具体类的实例化，而在工厂方法中则由一些子类来负责实例化。工厂方法用来处理对象的创建，并将行为封装在子类，这样基类的代码就和子类的对象创建完全解耦。</p><h1 id="三-抽象工厂"><a href="#三-抽象工厂" class="headerlink" title="三. 抽象工厂"></a>三. 抽象工厂</h1><p>当你需要创建的对象也依赖了一系列可变对象，那么就需要工厂模式中的最后一种方式–抽象工厂。我们首先给出抽象工厂的定义：</p><blockquote><p>提供一个借口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。<br>让我们再用Pizza来举例：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Pizza <span class="title">createPizza</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">PizzaIngredientFactory ingredientFactory =</span><br><span class="line"><span class="keyword">new</span> ChicagoPizzaIngredientFactory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (item.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Cheese Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> VeggiePizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Veggie Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> ClamPizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Clam Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> PepperoniPizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Pepperoni Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThickCrustDough();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PlumTomatoSauce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MozzarellaCheese();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Veggies[] createVeggies() &#123;</span><br><span class="line">Veggies veggies[] = &#123; <span class="keyword">new</span> BlackOlives(), </span><br><span class="line">                      <span class="keyword">new</span> Spinach(), </span><br><span class="line">                      <span class="keyword">new</span> Eggplant() &#125;;</span><br><span class="line"><span class="keyword">return</span> veggies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SlicedPepperoni();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FrozenClams();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PizzaStore</strong>和之前一样，这里就不重复了，和之前不一样的是在子类的<strong>createPizza</strong>方法中，我们不是简单的返回对象，而是根据创建对象所依赖的成员的不同，也进行了“个性化定制”。</p><h4 id="其本质上其实也是用工厂方法对依赖对象进行创建。"><a href="#其本质上其实也是用工厂方法对依赖对象进行创建。" class="headerlink" title="其本质上其实也是用工厂方法对依赖对象进行创建。"></a>其本质上其实也是用工厂方法对依赖对象进行创建。</h4><h1 id="四-抽象工厂与抽象方法的比较"><a href="#四-抽象工厂与抽象方法的比较" class="headerlink" title="四. 抽象工厂与抽象方法的比较"></a>四. 抽象工厂与抽象方法的比较</h1><ol><li>工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象，并将实例化延迟到子类。</li><li>抽象工厂使用组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li><li>抽象工厂创建相关的对象家族，并让他们集合起来，而不需要依赖他们的具体类</li></ol><h1 id="五-References"><a href="#五-References" class="headerlink" title="五. References"></a>五. References</h1><blockquote><p>《Head First 设计模式》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天正在看关于多线程的一些内容，看到线程池的时候发现它的实现使用了工厂模式，之前对工厂模式的了解不深，只是知道他是根据需要创建对象的，索性就开个支线，找了本书看了看关于工厂模式的一些知识，书中讲的也比较有意思，以下是一些心得。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82/"/>
    
      <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
  </entry>
  
</feed>
