<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Be Better</title>
  
  <subtitle>厚积薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-24T13:34:07.017Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MoriatyC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="http://yoursite.com/2018/02/24/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/02/24/HashMap源码解析/</id>
    <published>2018-02-24T06:25:16.000Z</published>
    <updated>2018-02-24T13:34:07.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="〇-简介"><a href="#〇-简介" class="headerlink" title="〇.简介"></a>〇.简介</h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/leitu.png" alt=""></p><p>下面针对各个实现类的特点做一些说明：</p><ol><li><p>HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p></li><li><p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p></li><li><p>LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p></li><li><p>TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p></li></ol><p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><p>在JDK8中HashMap的实现由原先的数组加链表，也就是通过链地址法，解决哈希冲突，变成了数组加链表加红黑树，如图所示<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/hashmap.png" alt=""></p><p>当链表长度大于8时，链表会变成红黑树，这样做的目的是为了改进之前由于hash函数选择不好导致链表过长的查询瓶颈，之后会具体介绍。</p><h1 id="一-关键参数及构造方法"><a href="#一-关键参数及构造方法" class="headerlink" title="一. 关键参数及构造方法"></a>一. 关键参数及构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//存储节点的table数组，第一次使用的时候初始化，必要时resize，长度总是2的幂 </span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//缓存entrySet，用于keySet() and values()  </span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//容器中元素的个数  </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//每次扩容和更改map结构的计数器  </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//阈值，当实际大小超过阈值时，会进行扩容  </span></span><br><span class="line">    <span class="keyword">int</span> threshold;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//装载因子  </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;      </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//默认的初始容量，必须是2的幂次，出于优化考虑，默认16  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//默认的最大容量  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//默认的装载因子，在无参构造器中默认设为该值  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//阈值，当链表中节点数大于该阈值后就会转变成红黑树  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//与上一个阈值相反，当小于这个阈值后转变回链表  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 看源码注释里说是：树的最小的容量，至少是 4 x TREEIFY_THRESHOLD = 32 然后为了避免(resizing 和 treeification thresholds) 设置成64  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//基本哈希容器节点 实现Map.Entry接口  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//不可变的哈希值，由关键字key得来  </span></span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">//不可变的关键字  </span></span><br><span class="line">        V value;  </span><br><span class="line">        Node&lt;K,V&gt; next;  </span><br><span class="line">  </span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.hash = hash;  </span><br><span class="line">            <span class="keyword">this</span>.key = key;  </span><br><span class="line">            <span class="keyword">this</span>.value = value;  </span><br><span class="line">            <span class="keyword">this</span>.next = next;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;<span class="comment">//Node对象的哈希值，关键字key的hashCode()与值value的hashCode()做异或运算    </span></span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;  </span><br><span class="line">            V oldValue = value;  </span><br><span class="line">            value = newValue;  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;<span class="comment">//对象相同或同类型且key-value均相同，则返回true    </span></span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;  </span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;  </span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;  </span><br><span class="line">                    Objects.equals(value, e.getValue()))  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 构造函数 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;<span class="comment">//给定初始容量和装载因子，构造一个空的HashMap  </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +  </span><br><span class="line">                                               initialCapacity);  </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  </span><br><span class="line">                                               loadFactor);  </span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//根据指定的容量计算容量，因为必须是2的幂次，虽然将该值赋给threshold，但表示的依然是容量，到时候会重新计算阈值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//指定初始容量，和默认装载因子0.75构造空HashMap  </span></span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;<span class="comment">//无参，使用默认的初始容量16,和装载因子0.75构造空的HashMap  </span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<span class="comment">//构造一个和给定Map映射相同的HashMap，默认装载因子，初始空间以足够存放给定Map中的映射为准   </span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;  </span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);  </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中给出了相应解释，下面再着重介绍几个参数。</p><h2 id="1-table数组"><a href="#1-table数组" class="headerlink" title="1. table数组"></a>1. table数组</h2><p>也就是我们之前所说的HashMap实现中的数组，通过对key计算hash后得到相应数组的index，数组中存储着相同index的链表首结点或者红黑树的根节点，结点类型就是上面代码中的<strong>Node</strong></p><h2 id="2-容量，-装载因子，阈值"><a href="#2-容量，-装载因子，阈值" class="headerlink" title="2. 容量， 装载因子，阈值"></a>2. 容量， 装载因子，阈值</h2><p>threshold = loadFactor * capcity</p><p>由于这样的一个对应关系，这三个变量在HashMap中只有threshold和loadFactor这两个是明确给出来的。在给出初始容量和装载因子的构造函数中我们可以发现，<strong>threshold</strong>被作为了初始化的容量变量，他将在第一次调用<strong>resize()</strong>中被使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>容量的默认值是16，装载因子默认为0.75, 至于为什么要有装载因子这个设定，而不是在table数组满了再扩容，文档中是这么说的</p><blockquote><p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p></blockquote><p>意思总结差不多就是这是时间和空间均衡后的决定。我们也知道hashmap是用空间换时间，0.75这个装载因子能在二者之间达到一个比较好的平衡。反正就是我们不要乱改就好了。</p><h1 id="二-关键方法"><a href="#二-关键方法" class="headerlink" title="二. 关键方法"></a>二. 关键方法</h1><h2 id="1-hash"><a href="#1-hash" class="headerlink" title="1.hash()"></a>1.hash()</h2><p>在对hashCode()计算hash时具体实现是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>他的执行过程如图所示：<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/hashcode.png" alt=""><br>其实就是将本身的hashcode的高16位和低16位做了一个异或操作。至于为什么要这么做呢？这里牵扯到了table数组中index的计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>n为数组的长度，而table长度n为2的幂，而计算table数组下标的时候，举个例子，加入n=16，那么n-1=15的二进制表示就是0x0000 1111，可以看出，任何一个2的幂次减1后二进制肯定都是这种形式，它的意义在于，任何一个值和它做&amp;操作，得到的结构肯定都在0~(n-1)之间，也就是说计算出来的下标值肯定数组的合法下标，这种方式由于使用了位运算比单纯的取模更快。</p><p>但问题也来了，设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。</p><p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p><h2 id="2-put"><a href="#2-put" class="headerlink" title="2.put"></a>2.put</h2><p>put方法的流程如下：</p><ol><li>如果table数组为空，那么调用resize()方法新建数组</li><li>对key的hashCode()做hash，然后再计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，放在以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);  </span><br><span class="line"> &#125;      </span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 实现Map.put以及相关方法 </span></span><br><span class="line"><span class="comment">  * 向map中加入个节点 </span></span><br><span class="line"><span class="comment">  * 没有分析onlyIfAbsent和evict </span></span><br><span class="line"><span class="comment">  */</span>       </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K, V&gt;[] tab;<span class="comment">//指向table数组  </span></span><br><span class="line">    Node&lt;K, V&gt; p;<span class="comment">//对应下标中的第一个节点，为null说明没有碰撞，不为null代表链表第一个元素或红黑树根节点  </span></span><br><span class="line">    <span class="keyword">int</span> n, i;<span class="comment">//n为table数组的长度，2的幂次; i表示对应的下标index  </span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 如果table为空即第一次添加元素，则进行初始化  </span></span><br><span class="line">        n = (tab = resize()).length;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 计算下标，根据hash与n计算index </span></span><br><span class="line"><span class="comment">     * 公式:i = (n - 1) &amp; hash; </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="comment">// p=table[i]; 对应下标中的第一个节点  </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// p为null说明没有碰撞，  </span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//直接新建一个节点加入就可以了  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// p不为null，说明有碰撞  </span></span><br><span class="line">        Node&lt;K, V&gt; e;<span class="comment">//e，代表map中与给定key值相同的节点  </span></span><br><span class="line">        K k;<span class="comment">//代表e的key  </span></span><br><span class="line">        <span class="comment">// p的关键字与要加入的关键字相同，则p就是要找的e  </span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            e = p;  </span><br><span class="line">        <span class="comment">// 如果p的类型是红黑树，则向红黑树中查找e  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);  </span><br><span class="line">        <span class="comment">// 否则就是链表  </span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>;; ++binCount) &#123;<span class="comment">//遍历链表查找e，如果找不到就新建一个  </span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">// 如果next为null，说明没有找到  </span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">// 那么新创建一个节点  </span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 加入节点后如果超出树形化阈值  </span></span><br><span class="line">                        treeifyBin(tab, hash);<span class="comment">// 则转换为红黑树  </span></span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; <span class="comment">// 找到关键字相同的节点，退出循环  </span></span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                p = e;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//e不为null，说明原来存在对应的key，那么返回原来的值  </span></span><br><span class="line">            V oldValue = e.value;<span class="comment">// 保留原来的值，用于返回  </span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)  </span><br><span class="line">                e.value = value;  </span><br><span class="line">            afterNodeAccess(e);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//说明新插入了一个节点，返回null  </span></span><br><span class="line">    ++modCount;  </span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 超过临界值，则resize  </span></span><br><span class="line">        resize();  </span><br><span class="line">    afterNodeInsertion(evict);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-get-和-containsKey-方法"><a href="#3-get-和-containsKey-方法" class="headerlink" title="3. get() 和 containsKey()方法"></a>3. get() 和 containsKey()方法</h2><p>这两个方法是最常用的，都是根据给定的key值，一个获取对应的value，一个判断是否存在于Map中，在内部这两个方法都会调用一个finall方法，就是getNode()，也就是查找对应key值的节点。</p><p>getNode方法的大致过程：</p><ol><li>table里的第一个节点，直接命中；</li><li>如果有冲突，则遍历链表或二叉树去查找相同节点</li><li>查找节点时先判断hash值是否相等</li><li>如果hash值相等，再判断key值是否相等</li><li>判断key值相等时，用==或equals或，整个判断条件为：</li></ol><p><strong>(e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt; e;  </span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 实现Map.get以及相关方法 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//指向table数组  </span></span><br><span class="line">    Node&lt;K,V&gt; first, e; <span class="comment">//first为table[index]，即所在数组下标中第一个节点；e用于遍历节点  </span></span><br><span class="line">    <span class="keyword">int</span> n; K k;<span class="comment">//n为table的长度，k用于指向节点的key  </span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;<span class="comment">//首先必须保证table数组不为空                 </span></span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//计算下标，保证数组下标中第一个节点不为null不然就肯定找不到直接返回null  </span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 先检查第一个节点hash值是否相等  </span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//再判断key，如果相等直接返回  </span></span><br><span class="line">            <span class="keyword">return</span> first;  </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123; <span class="comment">//第一个不符合，就从下一个开始找  </span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//红黑树 O(logn)  </span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  </span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">//不然就是链表O(n)  </span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                    <span class="keyword">return</span> e;  </span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-resize"><a href="#4-resize" class="headerlink" title="4. resize()"></a>4. resize()</h2><p>从<strong>put</strong>函数我们不难看出，当table数组为空，或者当加入某个元素后超过阈值，都会调用resize()进行扩容，他的目的就在于将链表和红黑树分散，使得碰撞分散，提高查询效率。简单来说就是下面的步骤：</p><ol><li>将容量和阈值扩大两倍，如果超过最大值就使用最大值最为新的容量和阈值</li><li>新建一个大小为新容量的table，然后将之前的结点放进去</li></ol><p>这里有一个很有意思的小技巧，还记得我们的index是怎么计算的吗？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure></p><p>假设我们的容量没有超标，由于容量都是2的幂，这里的n扩大2倍，相当于在原来的n-1的基础上高位增加了一个1，说白了就是多取了一位的hash。如图所示<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/resize.png" alt=""><br>所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置，因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/resize2.png" alt=""></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/resize3.png" alt=""><br>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;  </span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;  </span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;  </span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * step1: 先根据容量和阈值确定新的容量和阈值 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="comment">//case1: 如果table已经被初始化，说明不是第一次加入元素  </span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;              </span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//如果table的容量已经达到最大值，那么就不再扩容了，碰撞也没办法  </span></span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="comment">//那么扩大阈值到最大值  </span></span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//原来的table不变  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//不然的话table的容量扩大2倍，newCap = oldCap &lt;&lt; 1            大部分情况下肯定都是这种情况              </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;  </span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)  </span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//阈值也扩大2倍  </span></span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="comment">//case2: table没有被初始化，但是阈值大于0，说明在构造函数中指定了容量，但是容量存在阈值那个变量上  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)  </span><br><span class="line">        newCap = oldThr;<span class="comment">//那么将阈值设置为table的容量，下面还会重新计算阈值  </span></span><br><span class="line">    <span class="comment">//case3: table和阈值都没有初始化，说明是无参构造函数  </span></span><br><span class="line">    <span class="keyword">else</span> &#123;                 </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//使用默认的初始容量  </span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//计算默认的阈值，threshold=load_factor*capacity  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//重新计算阈值  </span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;  </span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?  </span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * step2: 更新阈值和新容量的table </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    threshold = newThr;  </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)  </span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];  </span><br><span class="line">    table = newTab;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * step3: 将原来table中元素，加入到新的table中 </span></span><br><span class="line"><span class="comment">     */</span>               </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;  </span><br><span class="line">            Node&lt;K,V&gt; e;  <span class="comment">//e = oldTab[j]</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)  <span class="comment">//e所在位置没有哈希冲突，只有一个元素，直接计算</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//e所在位置是一颗红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);  </span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">// e所在位置是一个链表，则遍历链表</span></span><br><span class="line">                  <span class="comment">// 根据e.hash &amp; oldCap) == 0，确定放入lo还是hi两个链表</span></span><br><span class="line">                  <span class="comment">// 其实就是判断e.hash是否大于oldCap</span></span><br><span class="line">                  <span class="comment">// lo和hi两个链表放分别放在在newTab[j]和newTab[j + oldCap]</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;  </span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;  </span><br><span class="line">                    Node&lt;K,V&gt; next;  </span><br><span class="line">                    <span class="keyword">do</span> &#123;  </span><br><span class="line">                        next = e.next;  </span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)  </span><br><span class="line">                                loHead = e;  </span><br><span class="line">                            <span class="keyword">else</span>  </span><br><span class="line">                                loTail.next = e;  </span><br><span class="line">                            loTail = e;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">else</span> &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)  </span><br><span class="line">                                hiHead = e;  </span><br><span class="line">                            <span class="keyword">else</span>  </span><br><span class="line">                                hiTail.next = e;  </span><br><span class="line">                            hiTail = e;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);  </span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;  </span><br><span class="line">                        newTab[j] = loHead;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;  </span><br><span class="line">                        newTab[j + oldCap] = hiHead;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> newTab;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-性能探讨"><a href="#三-性能探讨" class="headerlink" title="三. 性能探讨"></a>三. 性能探讨</h1><h2 id="1-hashcode"><a href="#1-hashcode" class="headerlink" title="1.hashcode()"></a>1.hashcode()</h2><p>HashMap的查询效率我们理论上看做是O(1),这是在没有发生冲突的情况下，但是当发生冲突较严重的时候，我们会浪费很多的时间在链表的查询或者红黑树的查询，以至于退化为O(n)或者O(logn),所以当作为key的类型，其Hashcode()函数的设计尤为重要。</p><h2 id="2-Key的要求"><a href="#2-Key的要求" class="headerlink" title="2. Key的要求"></a>2. Key的要求</h2><p>由上一条可知，一个作为key的类型，首先需要有一个设计良好的Hashcode函数，其次我们发现，在<strong>get</strong>函数中，我们首先判断hashcode相等，再判断equals()或者==来判断是否为同一个对象，因为hashcode相等的两个对象不一定相等，由此可见作为key的另一个条件时重写了equals方法。最后还有一个隐藏条件，key需要为不可变对象比如String，什么叫不可变对象呢？<br><strong>不可变对象就是创建后状态不能修改的对象</strong>，因为只有这样才能确保hashcode不发生变化，才能保证能找到相应的key，总结起来就是一下三个：</p><ol><li>重写hashcode（）</li><li>重写equals（）</li><li>不可变对象</li></ol><h1 id="四-引用"><a href="#四-引用" class="headerlink" title="四. 引用"></a>四. 引用</h1><blockquote><p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/java-hashmap.html</a><br><a href="http://paine1690.github.io/2016/11/12/Java/JDK/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://paine1690.github.io/2016/11/12/Java/JDK/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a><br><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;〇-简介&quot;&gt;&lt;a href=&quot;#〇-简介&quot; class=&quot;headerlink&quot; title=&quot;〇.简介&quot;&gt;&lt;/a&gt;〇.简介&lt;/h1&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Ha
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>缓存穿透、缓存雪崩、hot key</title>
    <link href="http://yoursite.com/2018/02/03/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81hot-key/"/>
    <id>http://yoursite.com/2018/02/03/缓存穿透、缓存雪崩、hot-key/</id>
    <published>2018-02-03T09:29:13.000Z</published>
    <updated>2018-02-03T09:33:21.988Z</updated>
    
    <content type="html"><![CDATA[<p>在做排行榜的时候，对缓存的更新频率产生了一定的疑问，在网上也看了不少博客对这方面的介绍，这里对看到的知识做个总结。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时要查询数据库，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="1-空值缓存"><a href="#1-空值缓存" class="headerlink" title="1. 空值缓存"></a>1. 空值缓存</h4><p>这是一个比较简单暴力的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li><p>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p></li><li><p>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p></li></ul><h4 id="2-Bloom-Filter"><a href="#2-Bloom-Filter" class="headerlink" title="2. Bloom Filter"></a>2. Bloom Filter</h4><p>Bloom Filter是一个占用空间很小、效率很高的随机数据结构，它由一个bit数组和一组Hash算法构成。可用于判断一个元素是否在一个集合中，查询效率很高（1-N，最优能逼近于1）。<br>在很多场景下，我们都需要一个能迅速判断一个元素是否在一个集合中。譬如：</p><ol><li>网页爬虫对URL的去重，避免爬取相同的URL地址；</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；</li><li>缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>初始化状态是一个全为0的bit数组</p><p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/bloom.jpg" alt=""></p><p>为了表达存储N个元素的集合，使用K个独立的函数来进行哈希运算。x1，x2……xk为k个哈希算法。<br>如果集合元素有N1，N2……NN，N1经过x1运算后得到的结果映射的位置标1，经过x2运算后结果映射也标1，已经为1的报错1不变。经过k次散列后，对N1的散列完成。<br>依次对N2，NN等所有数据进行散列，最终得到一个部分为1，部分位为0的字节数组。当然了，这个字节数组会比较长，不然散列效果不好。</p><p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/bloom2.jpg" alt=""></p><p>那么怎么判断一个外来的元素是否已经在集合里呢，譬如已经散列了10亿个垃圾邮箱，现在来了一个邮箱，怎么判断它是否在这10亿里面呢？<br>很简单，就拿这个新来的也依次经历x1，x2……xk个哈希算法即可。<br>在任何一个哈希算法譬如到x2时，得到的映射值有0，那就说明这个邮箱肯定不在这10亿内。<br>如果是一个黑名单对象，那么可以肯定的是所有映射都为1，肯定跑不了它。也就是说是坏人，一定会被抓。<br>那么误伤是为什么呢，就是指一些非黑名单对象的值经过k次哈希后，也全部为1，但它确实不是黑名单里的值，这种概率是存在的，但是是可控的。</p><p>至于具体实现，可以直接调用<strong>com.google.guava</strong>中的BloomFilter，就不赘述了。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li><li>加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。</li></ol><h2 id="热key重建"><a href="#热key重建" class="headerlink" title="热key重建"></a>热key重建</h2><p>开发人员使用缓存 + 过期时间的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：</p><ul><li>当前 key 是一个热点 key( 例如一个热门的娱乐新闻），并发量非常大。</li><li>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。</li></ul><p>在缓存失效的瞬间，有大量线程来重建缓存 ( 如下图)，造成后端负载加大，甚至可能会让应用崩溃。<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/hot.png" alt=""></p><p>要解决这个问题也不是很复杂，但是不能为了解决这个问题给系统带来更多的麻烦，所以需要制定如下目标：</p><ul><li>减少重建缓存的次数</li><li>数据尽可能一致</li><li>较少的潜在危险</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1. 互斥锁"></a>1. 互斥锁</h4><p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p><p>这种方案思路比较简单，但是存在一定的隐患，如果构建缓存过程出现问题或者时间较长，可能会存在死锁和线程池阻塞的风险，但是这种方法能够较好的降低后端存储负载并在一致性上做的比较好。</p><h4 id="2-不设置超时时间"><a href="#2-不设置超时时间" class="headerlink" title="2. 不设置超时时间"></a>2. 不设置超时时间</h4><p>“永远不过期”包含两层意思：</p><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li><li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ul><p>这种方案由于没有设置真正的过期时间，实际上已经不存在热点 key 产生的一系列危害，但是会存在数据不一致的情况，同时代码复杂度会增大。</p><blockquote><p><a href="http://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug</a><br><a href="http://blog.csdn.net/tianyaleixiaowu/article/details/74721877" target="_blank" rel="noopener">http://blog.csdn.net/tianyaleixiaowu/article/details/74721877</a><br><a href="http://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">http://blog.csdn.net/zeb_perfect/article/details/54135506</a><br><a href="https://zhuanlan.zhihu.com/p/26151305" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26151305</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在做排行榜的时候，对缓存的更新频率产生了一定的疑问，在网上也看了不少博客对这方面的介绍，这里对看到的知识做个总结。&lt;/p&gt;
&lt;h2 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透&quot;&gt;&lt;/a&gt;缓存穿透&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>redis排行榜</title>
    <link href="http://yoursite.com/2018/02/03/redis%E6%8E%92%E8%A1%8C%E6%A6%9C/"/>
    <id>http://yoursite.com/2018/02/03/redis排行榜/</id>
    <published>2018-02-03T09:24:30.000Z</published>
    <updated>2018-02-04T12:14:42.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>因为看了一段时间的redis，准备动手做一个小demo，做一个排行榜，正好加在之前的未完成的新闻门户里面。关于排行榜他有一些跟排行榜本身相关的要求比如：</p><h4 id="排行精确性"><a href="#排行精确性" class="headerlink" title="排行精确性"></a>排行精确性</h4><p>如果一个排行榜的结果关系到用户的权益问题，这个时候一个排行榜的精确性就需要非常高，比如一个运营同学进行了根据微博转发数量的营销活动，这个时候微博转发数量的排行榜就需要非常精确，否则会影响用户权益的分发。</p><h4 id="排行榜实时性"><a href="#排行榜实时性" class="headerlink" title="排行榜实时性"></a>排行榜实时性</h4><p>游戏和社交互动的结合是目前的趋势，对于热门游戏的排行是用户的关注重点，在这部分用户中对于排行的实时性有很高的要求，如果一个用户升级了自己的装备和能力，而自己的排名一直没有更新，那这个用户一定要非常伤心抛弃这个游戏了。所以通过离线计算等平台来构建一个非实时的排行榜系统就不太适合这样的模型。</p><h4 id="海量数据排行"><a href="#海量数据排行" class="headerlink" title="海量数据排行"></a>海量数据排行</h4><p>海量数据是目前的一个趋势，比如对于淘宝全网商品的一个排行，这个榜单将会是一个亿级别的，所以我们设计的榜单也需要具备弹性伸缩能力，同时在对海量数据进行排行的时候拥有一定的实时性。</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>目的是要实现一个热点新闻排行榜的话，毫无疑问，使用的是redis内置的zset这种数据结构，他可以根据score自动产生rank比较方便。我们将评论或者点赞数超过200的认为是热门文章</p><p>由于文章是从别的地方爬过来的，所以只有评论数没有点赞数，设置初始化分数为：</p><p><strong>score = 发布时间毫秒数 + 432 * 评论数</strong></p><p>而问题就在排行榜更新的频率，更新过快，缓存效果不好，会产生类似重建热key的问题（下一篇文章要讲一下），但是频率过慢又不能达到实时性，所以正如之前所说的，要根据排行榜自身的要求制定一个适合的更新策略：</p><p>针对自身的这个项目需求，我想实现的是一个热点新闻排行榜，他的时效性要求并不是很高，所以通过分析网易新闻的爬取量，对爬到的每个新闻建立一个<strong>news：id</strong>进行初始化，并设置一周后过期自动删除，排行榜肯定是用zset的，但是为了不刷新过快，再建立一个zset缓存最近一个星期的文章，通过一个定时任务，每周一次定时维护<strong>time：</strong>，从<strong>time:</strong> 删除时间超过一个星期的文章，并重置<strong>score：</strong>，由于爬虫每隔6小时更新一次，且新闻量相对较小，所以对time：的频繁读写是可以容忍的。所以总的来说就是</p><ol><li>爬取新闻，建立新的hash(news:id),设置过期时间为一周，并加入zset(time：)</li><li>每周执行一次更新，删除zset：中过期的任务，对未过期的任务分数进行更新。</li></ol><table><thead><tr><th>score：</th><th>zset</th></tr></thead><tbody><tr><td>news：id</td><td>分数</td></tr></tbody></table><table><thead><tr><th>time：</th><th>zset</th></tr></thead><tbody><tr><td>news：id</td><td>时间</td></tr></tbody></table><table><thead><tr><th>news：id</th><th>hash</th></tr></thead><tbody><tr><td>voted</td><td>投票数</td></tr><tr><td>title</td><td>xxx </td></tr><tr><td>url</td><td>xxx </td></tr></tbody></table><p>这里介绍一个在网上看到的实时排行榜的设计策略，其思路类似于维护一个小顶堆：</p><ol><li><p>第一次访问的时候，查数据库，查整个表查出topN（使用sql排序），丢给redis(使用sorted set数据类型)。</p></li><li><p>排序在redis，redis自动排序。以后的用户访问：均访问redis。</p></li><li><p>只要每次积分变化判断的时候拿topN的最后一个判别，大于最后一名，则整个user丢进redis排序。<br>效率性能再优化：用户积分变动的时候，（守护线程）服务器预存一下变化的数量。。到一定量再通知。</p></li><li><p>再往下去设定一个小距离为阈值。比如现在第50名的积分是100，那80分一下的应该就没必要扔给redis了吧？</p></li></ol><p>注意：这个排行榜的用户是会不断增加的，比如1亿用户，如果刚开始只有前50，后5千万人的积分大于第50名，那么就会往redis加入这个用户的信息。（虽然看起来要存很多，其实一亿用户怎么存也就1G左右的内存，简单暴力优雅方案了）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisDao redisDao;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE_WEEK_IN_SECONDS = <span class="number">7</span> * <span class="number">86400</span>;</span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 0 1/7 * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updataRank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    redisDao.zRemRangeByRank(<span class="string">"score:"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> cutOff = System.currentTimeMillis() / <span class="number">1000</span> - ONE_WEEK_IN_SECONDS;</span><br><span class="line">    Set&lt;TypedTuple&lt;Object&gt;&gt; set = redisDao.zRangeWithScores(<span class="string">"time:"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (TypedTuple&lt;Object&gt; o: set) &#123;</span><br><span class="line">        <span class="comment">//如果过期直接删除，否则计算结果</span></span><br><span class="line">        BigDecimal db = <span class="keyword">new</span> BigDecimal(o.getScore().toString());db.toPlainString();</span><br><span class="line">        <span class="keyword">if</span> (Long.valueOf(db.toPlainString()) &lt; cutOff) &#123;</span><br><span class="line">            redisDao.zrem(<span class="string">"time:"</span>, o.getValue());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisDao.zadd(<span class="string">"score:"</span>, o.getValue(), </span><br><span class="line">                    Double.valueOf(o.getScore().toString()) + </span><br><span class="line">                    <span class="number">432</span> * Double.valueOf(redisDao.hget(o.getValue().toString(), <span class="string">"voted"</span>).toString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>成品效果如图（忽略我这个丑陋的前端)：<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/xiaoguo.png" alt=""></p><h3 id="新闻爬虫2-0"><a href="#新闻爬虫2-0" class="headerlink" title="新闻爬虫2.0"></a>新闻爬虫2.0</h3><p>由于这次修改也涉及到了之前爬取数据的爬虫，索性就把爬虫也一并进行了修改，对整个爬虫进行了重构，使用多线程对爬虫进行优化，具体步骤如下：</p><p>将爬虫分为两个部分，使用生产者和消费者模式，将redis作为任务队列，生产者爬虫爬取新闻url，消费者爬虫根据新闻url爬取具体信息。使用2个redis集合存储已爬新闻和未爬新闻，作为简单去重。</p><p>完整代码请参考：</p><blockquote><p>新闻门户代码：<a href="https://github.com/MoriatyC/OmegaNews" target="_blank" rel="noopener">https://github.com/MoriatyC/OmegaNews</a></p><p>爬虫代码：<a href="https://github.com/MoriatyC/nethard" target="_blank" rel="noopener">https://github.com/MoriatyC/nethard</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计思路&quot;&gt;&lt;a href=&quot;#设计思路&quot; class=&quot;headerlink&quot; title=&quot;设计思路&quot;&gt;&lt;/a&gt;设计思路&lt;/h2&gt;&lt;p&gt;因为看了一段时间的redis，准备动手做一个小demo，做一个排行榜，正好加在之前的未完成的新闻门户里面。关于排行榜他有一些
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis数据安全与性能保障</title>
    <link href="http://yoursite.com/2018/01/29/redis%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BF%9D%E9%9A%9C/"/>
    <id>http://yoursite.com/2018/01/29/redis数据安全与性能保障/</id>
    <published>2018-01-29T13:03:54.000Z</published>
    <updated>2018-01-30T07:47:45.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-持久化"><a href="#一-持久化" class="headerlink" title="一.持久化"></a>一.持久化</h2><h4 id="1-快照：-将存在于某一时刻的所有数据都写入硬盘里面"><a href="#1-快照：-将存在于某一时刻的所有数据都写入硬盘里面" class="headerlink" title="1. 快照： 将存在于某一时刻的所有数据都写入硬盘里面"></a>1. 快照： 将存在于某一时刻的所有数据都写入硬盘里面</h4><h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><ol><li>客户端通过向redis发送bgsave命令（创建子进程）</li><li>客户端通过向redis发送save命令，但是会<strong>阻塞</strong>其他命令，所以只有内存不够，或者不怕阻塞的时候才可以用。但是不要创建子进程，不会导致redis停顿，并且由于没有子进程抢资源所以比bgsave快。</li><li>设置了save选项：比如 save 60 10000，表示从最近一次创建快照之后开始算起，当有60s内有10000次写入的时候就会触发bgsave命令，可以有多个save配置，任意一个满足即可。</li><li>通过shutdown接收到关闭请求时，或者接收到标准的term信号，执行save命令</li><li>当一个redis服务器连接另一个redis服务器，想对方发送sync时，若主服务器没执行bgsave，或者并非刚刚执行完，那么主服务器就会执行bgsave。</li></ol><h5 id="缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。"><a href="#缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。" class="headerlink" title="缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。"></a>缺点：当redis、系统或者硬件中的一个发生崩溃，将丢失最近一次创建快照后的数据。</h5><p><strong>TIPS: 将开发环境尽可能的模拟生产环境以得到正确的快照生成速率配置。</strong></p><h4 id="2-AOF：在执行写命令时，将被执行的写命令复制到硬盘里面"><a href="#2-AOF：在执行写命令时，将被执行的写命令复制到硬盘里面" class="headerlink" title="2. AOF：在执行写命令时，将被执行的写命令复制到硬盘里面"></a>2. AOF：在执行写命令时，将被执行的写命令复制到硬盘里面</h4><p>使用appendonlyyes配置选项打开，下图是appendfsync配置选项。</p><table><thead><tr><th>选项目</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写操作都要同步写入，严重降低redis速度损耗硬盘寿命</td></tr><tr><td>everysec</td><td>每秒执行一次，将多个写入同步，墙裂推荐</td></tr><tr><td>no</td><td>让os决定，不稳定，不知道会丢失多少数据</td></tr></tbody></table><p>自动配置aof重写：</p><ul><li>auto-aof-rewrite-percentage 100</li><li>auto-aof-rrewrite-min-size 64<br>当启用aof持久化之后，当aof文件体积大于64mb并且体积比上一次大了100%，就会执行bgrewriteaof命令。</li></ul><p><strong>缺点：1.aof文件过大，2. 文件过大导致还原事件过长。<br>但是可以对其进行重写压缩。</strong></p><h2 id="二-复制"><a href="#二-复制" class="headerlink" title="二. 复制"></a>二. 复制</h2><p>就像之前所说当一个从服务器连接一个主服务器的时候，主服务器会创建一个快照文件并将其发送到从服务器。</p><p>在配置中包含slaveof host port选项指定主服务器，启动时候会先执行aof或者快照文件。</p><p>也可以通过发送flaveof no one命令来终止复制操作，通过slaveof host port命令来开始复制一个主服务器，会直接执行下面的连接操作。</p><table><thead><tr><th>步骤</th><th>主服务器操作</th><th>从服务器操作</th></tr></thead><tbody><tr><td>1</td><td>（等待命令）</td><td>连接主服务器，发送sync命令</td></tr><tr><td>2</td><td>开始执行bgsave，并使用缓冲区记录bgsave之后执行的所有写命令</td><td>根据配置选项决定使用现有数据处理客户端请求还是返回错误</td></tr><tr><td>3</td><td>Bgsave执行完毕，向从服务器发快照，并在发送期间继续用缓冲区记录写命令</td><td>丢弃所有旧数据，载入快照文件</td></tr><tr><td>4</td><td>快照发送完毕，向从服务器发送缓冲区里的写命令</td><td>完成快照解释，开始接受命令</td></tr><tr><td>5</td><td>缓冲区存储的写命令发送完毕：从现在起每执行一个写命令都发给从服务器</td><td>执行主服务器发来的所有存储在缓冲区里的写；并接受执行主服务器发来的写命令</td></tr></tbody></table><h2 id="三-处理故障系统"><a href="#三-处理故障系统" class="headerlink" title="三. 处理故障系统"></a>三. 处理故障系统</h2><h4 id="验证快照和aof文件"><a href="#验证快照和aof文件" class="headerlink" title="验证快照和aof文件"></a>验证快照和aof文件</h4><ul><li>redis-check-aof</li><li>redis-check-dump</li></ul><p>检查aof和快照文件的状态，在有需要的情况下对aof文件进行修复。</p><h4 id="更换新的故障主服务器"><a href="#更换新的故障主服务器" class="headerlink" title="更换新的故障主服务器"></a>更换新的故障主服务器</h4><p>假设A为主服务器，B为从服务器，当机器A发生故障的时候，更换服务器的步骤如下：<br>首先向机器B发送一个save命令，将这个快照文件发送给机器C，在C上启动Redis，让B成为C的从服务器。</p><h4 id="将从服务器升级为主服务器"><a href="#将从服务器升级为主服务器" class="headerlink" title="将从服务器升级为主服务器"></a>将从服务器升级为主服务器</h4><p>将从服务器升级为主服务器，为升级后的主服务器创建从服务器。</p><h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><h2 id="四-事务"><a href="#四-事务" class="headerlink" title="四. 事务"></a>四. 事务</h2><p>multi: 标记一个事务块的开始。</p><p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p><p>exec: 执行所有事务块内的命令。</p><p>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p><p>redis的事务包裹在multi命令和exec命令之中，在jedis中通过如下实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisJava</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Response&lt;String&gt; ret;</span><br><span class="line">    Jedis conn = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Transaction t = conn.multi();</span><br><span class="line">        t.incr(<span class="string">"notrans:"</span>);</span><br><span class="line">        Response&lt;String&gt; result1 = t.get(<span class="string">"notrans:"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.incrBy(<span class="string">"notrans:"</span>, -<span class="number">1</span>);</span><br><span class="line">        t.exec();</span><br><span class="line">        String foolbar = result1.get();       </span><br><span class="line">        System.out.println(foolbar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> RedisJava();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> RedisJava();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> RedisJava();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>wathc：<br>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li><li>unwatch：<br>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。<br>的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</li><li>discard :取消事务，放弃执行事务块内的所有命令。取消watch，清空任务队列。<br>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</li></ul><p>一个简单的商品买卖demo如下：</p><table><thead><tr><th>key</th><th>type</th></tr></thead><tbody><tr><td>inventory：id</td><td>set</td></tr><tr><td>market</td><td>zset</td></tr><tr><td>user:id</td><td>hash</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">listItem</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Jedis conn, String itemId, String sellerId, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       String inventory = <span class="string">"inventory:"</span> + sellerId;</span><br><span class="line">       String item = itemId + <span class="string">'.'</span> + sellerId;</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis() + <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (System.currentTimeMillis() &lt; end) &#123;</span><br><span class="line">           conn.watch(inventory);</span><br><span class="line">           <span class="keyword">if</span> (!conn.sismember(inventory, itemId))&#123;</span><br><span class="line">               conn.unwatch();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Transaction trans = conn.multi();</span><br><span class="line">           trans.zadd(<span class="string">"market:"</span>, price, item);</span><br><span class="line">           trans.srem(inventory, itemId);</span><br><span class="line">           List&lt;Object&gt; results = trans.exec();</span><br><span class="line">           <span class="comment">// null response indicates that the transaction was aborted due to</span></span><br><span class="line">           <span class="comment">// the watched key changing.</span></span><br><span class="line">           <span class="keyword">if</span> (results == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">purchaseItem</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Jedis conn, String buyerId, String itemId, String sellerId, <span class="keyword">double</span> lprice)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       String buyer = <span class="string">"users:"</span> + buyerId;</span><br><span class="line">       String seller = <span class="string">"users:"</span> + sellerId;</span><br><span class="line">       String item = itemId + <span class="string">'.'</span> + sellerId;</span><br><span class="line">       String inventory = <span class="string">"inventory:"</span> + buyerId;</span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis() + <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (System.currentTimeMillis() &lt; end)&#123;</span><br><span class="line">           conn.watch(<span class="string">"market:"</span>, buyer);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">double</span> price = conn.zscore(<span class="string">"market:"</span>, item);</span><br><span class="line">           <span class="keyword">double</span> funds = Double.parseDouble(conn.hget(buyer, <span class="string">"funds"</span>));</span><br><span class="line">           <span class="keyword">if</span> (price != lprice || price &gt; funds)&#123;</span><br><span class="line">               conn.unwatch();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Transaction trans = conn.multi();</span><br><span class="line">           trans.hincrBy(seller, <span class="string">"funds"</span>, (<span class="keyword">int</span>)price);</span><br><span class="line">           trans.hincrBy(buyer, <span class="string">"funds"</span>, (<span class="keyword">int</span>)-price);</span><br><span class="line">           trans.sadd(inventory, itemId);</span><br><span class="line">           trans.zrem(<span class="string">"market:"</span>, item);</span><br><span class="line">           List&lt;Object&gt; results = trans.exec();</span><br><span class="line">           <span class="comment">// null response indicates that the transaction was aborted due to</span></span><br><span class="line">           <span class="comment">// the watched key changing.</span></span><br><span class="line">           <span class="keyword">if</span> (results == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>总结：相比于一般关系型数据库的悲观锁，redis的事务是典型的乐观锁，没有对事务进行封锁，以避免客户端运行过慢造成长时间的阻塞</p><h4 id="非事务型流水线"><a href="#非事务型流水线" class="headerlink" title="非事务型流水线"></a>非事务型流水线</h4><p>使用流水线，减少通信次数提高性能，以jedis为例，对比使用和没使用流水线的函数方法调用次数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTokenPipeline</span><span class="params">(Jedis conn, String token, String user, String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    Pipeline pipe = conn.pipelined();</span><br><span class="line">    pipe.multi();</span><br><span class="line">    pipe.hset(<span class="string">"login:"</span>, token, user);</span><br><span class="line">    pipe.zadd(<span class="string">"recent:"</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="keyword">null</span>)&#123;</span><br><span class="line">        pipe.zadd(<span class="string">"viewed:"</span> + token, timestamp, item);</span><br><span class="line">        pipe.zremrangeByRank(<span class="string">"viewed:"</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        pipe.zincrby(<span class="string">"viewed:"</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">    pipe.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对比没有使用流水线的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateToken</span><span class="params">(Jedis conn, String token, String user, String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    conn.hset(<span class="string">"login:"</span>, token, user);</span><br><span class="line">    conn.zadd(<span class="string">"recent:"</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conn.zadd(<span class="string">"viewed:"</span> + token, timestamp, item);</span><br><span class="line">        conn.zremrangeByRank(<span class="string">"viewed:"</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        conn.zincrby(<span class="string">"viewed:"</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试函数如下</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchmarkUpdateToken</span><span class="params">(Jedis conn, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">        Class[] args = <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">            Jedis.class, String.class, String.class, String.class&#125;;</span><br><span class="line">        Method[] methods = <span class="keyword">new</span> Method[]&#123;</span><br><span class="line">            <span class="keyword">this</span>.getClass().getDeclaredMethod(<span class="string">"updateToken"</span>, args),</span><br><span class="line">            <span class="keyword">this</span>.getClass().getDeclaredMethod(<span class="string">"updateTokenPipeline"</span>, args),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> end = start + (duration * <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; end)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                method.invoke(<span class="keyword">this</span>, conn, <span class="string">"token"</span>, <span class="string">"user"</span>, <span class="string">"item"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> delta = System.currentTimeMillis() - start;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    method.getName() + <span class="string">' '</span> +</span><br><span class="line">                    count + <span class="string">' '</span> +</span><br><span class="line">                    (delta / <span class="number">1000</span>) + <span class="string">' '</span> +</span><br><span class="line">                    (count / (delta / <span class="number">1000</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如图所示，在本地运行性能提升大概17.8倍。<img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/benchmark.png" alt=""></p><p>tips：可以使用redis-benchmark工具进行性能测试。</p><h2 id="五-References"><a href="#五-References" class="headerlink" title="五. References"></a>五. References</h2><blockquote><p>《Redis实战》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-持久化&quot;&gt;&lt;a href=&quot;#一-持久化&quot; class=&quot;headerlink&quot; title=&quot;一.持久化&quot;&gt;&lt;/a&gt;一.持久化&lt;/h2&gt;&lt;h4 id=&quot;1-快照：-将存在于某一时刻的所有数据都写入硬盘里面&quot;&gt;&lt;a href=&quot;#1-快照：-将存在于某一时刻的
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="nosql" scheme="http://yoursite.com/tags/nosql/"/>
    
      <category term="持久化" scheme="http://yoursite.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>线程池(二)</title>
    <link href="http://yoursite.com/2018/01/18/%E7%BA%BF%E7%A8%8B%E6%B1%A0(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/01/18/线程池(二)/</id>
    <published>2018-01-18T11:23:19.000Z</published>
    <updated>2018-01-30T11:25:09.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h3 id="饥饿死锁"><a href="#饥饿死锁" class="headerlink" title="饥饿死锁"></a>饥饿死锁</h3><p>如果线程池中的任务依赖于之后提交的子任务，当线程池不够大的时候，很容易造成饥饿死锁。所以最好在线程池中加入的是同类型的独立任务。</p><h3 id="运行时间较长的任务"><a href="#运行时间较长的任务" class="headerlink" title="运行时间较长的任务"></a>运行时间较长的任务</h3><p>如果线程运行时间较长也会影响任务的相应性，同样造成不好的体验，所以api有很多方法都带有一个限时版本。</p><h2 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h2><p>线程池的大小需要分析计算环境，资源预算和任务特性。</p><p>一般来说在知道了系统中有多少个cpu和内存的基础下，任务类型是最为重要的。</p><ul><li>对于计算密集型的任务线程池大小为cpu数+1，以实现尽可能的满载利用率</li><li>对于i/o密集型，由于线程不会一直执行，所以规模更大。这里给出一个《Java并发变成实战》这本书提出的一个公式</li></ul><blockquote><p>最佳线程数目 = （线程等待时间/线程CPU时间之比 + 1）<em> CPU数目</em>cpu利用率</p></blockquote><p>即等待时间越长，需要更多的线程。<br>当我们不需要一个那么精准的线程数目时，也可以用这个公式</p><blockquote><p>最佳线程数目 = 2N+1(N为CPU数目)</p></blockquote><h4 id="是否使用线程池就一定比使用单线程高效呢？"><a href="#是否使用线程池就一定比使用单线程高效呢？" class="headerlink" title="是否使用线程池就一定比使用单线程高效呢？"></a>是否使用线程池就一定比使用单线程高效呢？</h4><p>答案是否定的，比如Redis就是单线程的，但它却非常高效，基本操作都能达到十万量级/s。从线程这个角度来看，部分原因在于：</p><ul><li>多线程带来线程上下文切换开销，单线程就没有这种开销</li><li>锁</li><li>当然“Redis很快”更本质的原因在于：Redis基本都是内存操作，这种情况下单线程可以很高效地利用CPU。而多线程适用场景一般是：存在相当比例的IO和网络操作。</li></ul><h2 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h2><p>ThreadPoolExecutor提供了几个可以在子类化中该学的方法：</p><ul><li>beforeExecute</li><li>afterExecute</li><li>terminated</li></ul><p>如果beforeExecute抛出一个RuntimeException，那么任务将不被执行，并且afterExecute也不会被调用。</p><p>但是无论人物从run中正常返回还是抛出一个异常返回，afterExecute都会被调用，如果任务在完成后带有一个Error，那么久不会调用。</p><p>所有任务都已经完成并且所有工作者线程也已经关闭后，terminated会被调用。</p><p>给出一个demo，他通过这一些列方法来统计任务执行并添加日志。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimingThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = Logger.getLogger(<span class="string">"TimingThreadPool"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong numTasks = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong totalTime = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        log.fine(String.format(<span class="string">"Thread %s: start %s"</span>, t, r));</span><br><span class="line">        startTime.set(System.nanoTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> taskTime = endTime - startTime.get();</span><br><span class="line">            numTasks.incrementAndGet();</span><br><span class="line">            totalTime.addAndGet(taskTime);</span><br><span class="line">            log.fine(String.format(<span class="string">"Thread %s: end %s, time=%dns"</span>,</span><br><span class="line">                    t, r, taskTime));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(String.format(<span class="string">"Terminated: avg time=%dns"</span>,</span><br><span class="line">                    totalTime.get() / numTasks.get()));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.terminated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p><a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="noopener">http://ifeve.com/how-to-calculate-threadpool-size/</a><br>《Java并发编程实战》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性能问题&quot;&gt;&lt;a href=&quot;#性能问题&quot; class=&quot;headerlink&quot; title=&quot;性能问题&quot;&gt;&lt;/a&gt;性能问题&lt;/h2&gt;&lt;h3 id=&quot;饥饿死锁&quot;&gt;&lt;a href=&quot;#饥饿死锁&quot; class=&quot;headerlink&quot; title=&quot;饥饿死锁&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>线程池(一)</title>
    <link href="http://yoursite.com/2018/01/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/01/17/线程池(一)/</id>
    <published>2018-01-17T03:17:20.000Z</published>
    <updated>2018-01-30T11:22:50.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这几天准备深入学习有关并发的知识，所以先简单复习了一下JDK自带的并发包，其中首先比较重要的一个就是线程池了。</p><p>为什么不无限的创造线程？主要基于以下几个原因：</p><ol><li>线程生命周期的开销非常高</li><li>资源消耗</li><li>稳定性</li></ol><p>所谓物极必反，线程的创建和销毁和需要一定的时间，如果所创建的线程工作时间还不如创建销毁的时间长那是得不偿失的，并且当线程创建过多也会对内存造成一定的负担甚至溢出，并且对GC也是极大的消耗，由于存在一定数额的活跃线程也提高了响应性。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>根据《阿里巴巴Java开发手册》中对线程创建的要求</p><blockquote><ol><li>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</li></ol></blockquote><p>由此可见，在正式生产环境中，线程池是唯一的创建线程的方法。而JDK对线程池也有强大的支持。<img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/pool.png" alt=""></p><p>根据《手册》中的另一点要求</p><blockquote><ol><li>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明： Executors 返回的线程池对象的弊端如下：<br>1） FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>2） CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM</li></ol></blockquote><p>虽然Executor为我们提供了很多方便的工厂方法，比如<strong>newSingleThreadExecutor()</strong>,也有Executors为我们很好的实现了这些工厂方法，但是手动实现<strong>ThreadPoolExecutor</strong>能让我们对线程池有更深的了解和控制。所以接下来让我们来介绍一下<strong>ThreadPoolExecutor</strong>这个类。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一个最常见的<strong>ThreadPoolExecutor</strong>构造函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize, </span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime, </span><br><span class="line">                   TimeUnit unit, </span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">                   ThreadFactory threadFactory, </span><br><span class="line">                   RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ul><li>corePoolSize： 活动线程数</li><li>maximumPoolSize： 线程池上限</li><li>keepAliveTime： 当线程池中线程数超过corePoolSize后，完成工作后的线程存活时间</li><li>unit： 单位<br>其余的几个参数我们会在后面着重介绍。</li></ul><p>这里介绍一下ThreadPoolExecutor的核心工作原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br></pre></td></tr></table></figure><p>workderCountOf()获得当前线程池线程总数，若小于corePoolSize，则直接将任务通过addWorker<br>()方法执行，否则在workQueue.offer()进入等待队列，若进入失败，则任务直接交给线程池，若线程池达到了maximumPoolSize则提交失败执行拒绝策略</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><h3 id="BlockingQueue：接口，阻塞队列，数据共享通道"><a href="#BlockingQueue：接口，阻塞队列，数据共享通道" class="headerlink" title="BlockingQueue：接口，阻塞队列，数据共享通道"></a>BlockingQueue：接口，阻塞队列，数据共享通道</h3><p>任务队列的作用在于，当线程池中线程数达到corePoolSize的时候，接下来的任务将进入这个队列进行等待，等待执行。</p><h4 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h4><p>服务线程（获取队列信息并处理的线程）在队列为空时进行读等待，有新的消息进入队列后自动唤醒，反之，当队列满时进行写等待直到有消息出队。</p><p>不同于常用的offer()和poll()方法，这里我们使用take()和put()方法进行读写。我们以ArrayBlockingQueue的为例子,其中包括了这几个控制对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lick;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure></p><p>就拿take()来说<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当队列为空时，他会在<strong>notEmpty</strong>上进行等待，<br>在线程等待时，若有新的元素插入，线程就会被唤醒<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="常用实现"><a href="#常用实现" class="headerlink" title="常用实现"></a>常用实现</h4><ul><li>SynchronousQueue(直接提交队列): 一个零容量队列，每个插入操作要对应一个删除操作。提交的任务不会被真实保存，其实就是将新任务交给了线程执行。</li><li>ArrayBlockingQueue(有界任务队列): 这里就会用到线程池中另一个参数<strong>maximumPoolSize</strong>, 若当前线程池中线程小于corePoolSize则直接在线程池中增加线程，若大于，则加入该任务队列，若队列满则继续加入线程池，若线程池中数目多余maximumPoolSize则执行拒绝策略。</li><li>LinkedBlockingQueue(无界任务队列)：如果未指定容量，那么容量将等于 Integer.MAX_VALUE。只要插入元素不会使双端队列超出容量，每次插入后都将动态地创建链接节点。</li><li>PriorityBlockingQueue(优先任务队列)： 一个特殊的无界任务队列，前面两者都是按FIFO的顺序执行，而这个是可以按照优先级执行。<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2>JDK内置拒绝策略如下</li><li>AboerPolicy(默认）：直接抛出异常，阻止系统正常工作。</li><li>CallerRunsPolicy: 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。（伪丢弃，但是任务提交线程性能大幅度下降）</li><li>DiscardOledestPolicy:和名字一样，丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy: 丢弃无法处理的任务，不给任何处理。</li></ul><h2 id="异常堆栈"><a href="#异常堆栈" class="headerlink" title="异常堆栈"></a>异常堆栈</h2><p>首先给出一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = a / b;</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor pools = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, </span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            pools.submit(<span class="keyword">new</span> Main(<span class="number">100</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果如下</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">50</span></span><br><span class="line"><span class="comment">25</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>可以发现，其中一个显然的异常除数为0不见了，我们可以通过将submit方法改为execute方法来打印部分异常信息，但是我们仍然不能发现他的调用线程在哪儿。<br>这里我们通过扩展线程池给出一种解决办法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> first_maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.execute(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.submit(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Exception <span class="title">clientTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exception(<span class="string">"Client stack trace"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">wrap</span><span class="params">(<span class="keyword">final</span> Runnable task, <span class="keyword">final</span> Exception clientStack, String clientThreadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                    clientStack.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">"                             1212"</span>);</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们通过扩展<strong>ThreadPoolExecutor</strong>，将要执行的Runnable进行包装，通过手动创建异常，获取当前主线程的调用堆栈，从而得到线程池的调用信息，并打印相应的运行异常，这样我们就可以追踪到完整的异常信息。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用多线程的时候，要通过<strong>ThreadPoolExecutor</strong>来手动创建，根据当前任务的需求分配相应的线程池大小和阻塞队列以及拒绝策略，这样才能知根知底。</p><h1 id="五-References"><a href="#五-References" class="headerlink" title="五. References"></a>五. References</h1><blockquote><p>《实战Java高并发程序设计》</p><p>《阿里巴巴Java开发手册》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这几天准备深入学习有关并发的知识，所以先简单复习了一下JDK自带的并发包，其中首先比较重要的一个就是线程池了。&lt;/p&gt;
&lt;p&gt;为什么不无限的
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2018/01/13/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/13/工厂模式/</id>
    <published>2018-01-13T13:18:04.000Z</published>
    <updated>2018-01-17T08:49:29.755Z</updated>
    
    <content type="html"><![CDATA[<p>这两天正在看关于多线程的一些内容，看到线程池的时候发现它的实现使用了工厂模式，之前对工厂模式的了解不深，只是知道他是根据需要创建对象的，索性就开个支线，找了本书看了看关于工厂模式的一些知识，书中讲的也比较有意思，以下是一些心得。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于设计模式来说，模式本身固然重要，但是模式设计的思想也同样很有味道，其中带来的一些OO的原则更是我们平时写代码需要注意的地方。而对于OO的设计原则其中有一个重要的思想就是将固定与变化分开，也就是简单的策略模式，将变化抽象，针对同一个接口，有各自的实现。</p><p>但是对于创建对象来说，java中只有<strong>new</strong>这一种方法，这就不可避免的要将代码写死，这又是我们不想看到的事情，由于硬编码带来的一系列拓展上的不便，使我们无法针对<strong>接口</strong>编程。就好像当我们使用集合的使用都会这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> XXXList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>因为这种针对接口的编程给了我们更多的自由。那么有没有一种灵活的方式创建对象，那就是工厂模式，<strong>所有的工厂模式都是针对对象的创建</strong>。</p><h1 id="一-简单工厂"><a href="#一-简单工厂" class="headerlink" title="一.简单工厂"></a>一.简单工厂</h1><p>首先声明一下，简单工厂不是一种设计模式，只是一种习惯而已。他将动态的创建对象这一过程与固定的使用对象的代码分隔开。我们结合一个简单的例子来说：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line">SimplePizzaFactory factory;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span> </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza;</span><br><span class="line"> </span><br><span class="line">pizza = factory.createPizza(type);</span><br><span class="line"> </span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> ClamPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> VeggiePizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们所需要创建的对象是Pizza，但在这里我们通过一个<strong>factory</strong>代替了以往的<strong>new</strong>关键字来创建对象，而这样的好处也是显而易见的，在这个服务中，变化的是Pizza的种类，而处理Pizza 的流程是固定的。我们只需根据需要传入所需的factory，就能实现创建对象与使用对象的解耦。</p><h4 id="我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。"><a href="#我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。" class="headerlink" title="我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。"></a>我们通过定义一个工厂类，将创建对象的操作通过这个类来进行，当对象种类增加时，我们只需要修改工厂类，就是所谓类对修改关闭，对扩展开放。</h4><h1 id="二-工厂方法"><a href="#二-工厂方法" class="headerlink" title="二. 工厂方法"></a>二. 工厂方法</h1><p>在上一个例子中，我们在PizzaStore中创建简单工厂对象，通过简单工厂创建对象，这不免让代码失去了一点弹性，让我们进一步抽象，将创建对象的方法进一步封装，形成一个抽象基类，让每个子类去各自实现自己所需的创建对象的方法。提高代码的可扩展性。下面给出例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String item)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza = createPizza(type);</span><br><span class="line">System.out.println(<span class="string">"--- Making a "</span> + pizza.getName() + <span class="string">" ---"</span>);</span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Pizza <span class="title">createPizza</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStyleVeggiePizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStyleClamPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChicagoStylePepperoniPizza();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，对象的创建只给出了一个抽象方法，而具体的实现，则有子类自由选择决定，这样极大的丰富了代码的选择性和扩展性。基类实际上并不知道他持有的是什么对象，他主要负责持有对象后的一系列固定流程操作。</p><blockquote><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p></blockquote><h2 id="对比工厂方法和简单工厂"><a href="#对比工厂方法和简单工厂" class="headerlink" title="对比工厂方法和简单工厂"></a>对比工厂方法和简单工厂</h2><p>原本有一个对象负责所有具体类的实例化，而在工厂方法中则由一些子类来负责实例化。工厂方法用来处理对象的创建，并将行为封装在子类，这样基类的代码就和子类的对象创建完全解耦。</p><h1 id="三-抽象工厂"><a href="#三-抽象工厂" class="headerlink" title="三. 抽象工厂"></a>三. 抽象工厂</h1><p>当你需要创建的对象也依赖了一系列可变对象，那么就需要工厂模式中的最后一种方式–抽象工厂。我们首先给出抽象工厂的定义：</p><blockquote><p>提供一个借口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。<br>让我们再用Pizza来举例：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Pizza <span class="title">createPizza</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">PizzaIngredientFactory ingredientFactory =</span><br><span class="line"><span class="keyword">new</span> ChicagoPizzaIngredientFactory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (item.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Cheese Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> VeggiePizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Veggie Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> ClamPizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Clam Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> PepperoniPizza(ingredientFactory);</span><br><span class="line">pizza.setName(<span class="string">"Chicago Style Pepperoni Pizza"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThickCrustDough();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PlumTomatoSauce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MozzarellaCheese();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Veggies[] createVeggies() &#123;</span><br><span class="line">Veggies veggies[] = &#123; <span class="keyword">new</span> BlackOlives(), </span><br><span class="line">                      <span class="keyword">new</span> Spinach(), </span><br><span class="line">                      <span class="keyword">new</span> Eggplant() &#125;;</span><br><span class="line"><span class="keyword">return</span> veggies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pepperoni <span class="title">createPepperoni</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SlicedPepperoni();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FrozenClams();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PizzaStore</strong>和之前一样，这里就不重复了，和之前不一样的是在子类的<strong>createPizza</strong>方法中，我们不是简单的返回对象，而是根据创建对象所依赖的成员的不同，也进行了“个性化定制”。</p><h4 id="其本质上其实也是用工厂方法对依赖对象进行创建。"><a href="#其本质上其实也是用工厂方法对依赖对象进行创建。" class="headerlink" title="其本质上其实也是用工厂方法对依赖对象进行创建。"></a>其本质上其实也是用工厂方法对依赖对象进行创建。</h4><h1 id="四-抽象工厂与抽象方法的比较"><a href="#四-抽象工厂与抽象方法的比较" class="headerlink" title="四. 抽象工厂与抽象方法的比较"></a>四. 抽象工厂与抽象方法的比较</h1><ol><li>工厂方法使用继承，把对象的创建委托给子类，子类实现工厂方法来创建对象，并将实例化延迟到子类。</li><li>抽象工厂使用组合，对象的创建被实现在工厂接口所暴露出来的方法中。</li><li>抽象工厂创建相关的对象家族，并让他们集合起来，而不需要依赖他们的具体类</li></ol><h1 id="五-References"><a href="#五-References" class="headerlink" title="五. References"></a>五. References</h1><blockquote><p>《Head First 设计模式》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天正在看关于多线程的一些内容，看到线程池的时候发现它的实现使用了工厂模式，之前对工厂模式的了解不深，只是知道他是根据需要创建对象的，索性就开个支线，找了本书看了看关于工厂模式的一些知识，书中讲的也比较有意思，以下是一些心得。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82/"/>
    
      <category term="OO" scheme="http://yoursite.com/tags/OO/"/>
    
  </entry>
  
  <entry>
    <title>数据库隔离级别</title>
    <link href="http://yoursite.com/2017/11/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2017/11/26/数据库隔离级别/</id>
    <published>2017-11-26T08:29:12.000Z</published>
    <updated>2018-02-26T08:30:14.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="READ-UNCOMMITTED-未提交读"><a href="#READ-UNCOMMITTED-未提交读" class="headerlink" title="READ UNCOMMITTED(未提交读)"></a>READ UNCOMMITTED(未提交读)</h1><p>事务中的修改，即使没有提交，对其他事务也都是可见的，即读取了一个未提交的修改（脏读）</p><h1 id="READ-COMMITTED-提交读"><a href="#READ-COMMITTED-提交读" class="headerlink" title="READ COMMITTED(提交读)"></a>READ COMMITTED(提交读)</h1><p>大多数数据库的默认隔离级别(mysql不是)，满足ACID中的隔离性定义：一个事务开始时，只能看见已经提交的事务所做的修改。有点不能理解，在网上看到了一个例子：</p><p>singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为 何……</p><p>出现上述情况，即我们所说的不可重复读 ，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p><p>这里事务A两次读取到的数据都是已经提交的，不管是首次读取的2000，还是在B事务提交之后读取到的0，所以这个级别有时候也叫不可重复读。</p><p>当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读。</p><h1 id="REPEATABLE-READ-可重复度，-mysql默认级别"><a href="#REPEATABLE-READ-可重复度，-mysql默认级别" class="headerlink" title="REPEATABLE READ(可重复度， mysql默认级别)"></a>REPEATABLE READ(可重复度， mysql默认级别)</h1><p>该级别保证同一个事务多次读取的结果是一致的，在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。用上面的例子说就是当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。但是这个级别会产生幻读，所谓幻读，指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入新纪录，当前事务再次读取该范围的记录时会产生幻行。</p><h2 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h2><p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象<br>发生了幻觉一样。</p><p>不可重复读强调的是对同一个数据的修改得到两个不同的结果，幻读强调的是对结果集的插入或删除操作，产生了新的结果集。</p><h1 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable (序列化)"></a>Serializable (序列化)</h1><p>Serializable 是最高的事务隔离级别，强制事务串行执行，简单来说就是读取的每一行数据都加锁，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p><p>√: 可能出现    ×: 不会出现</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td><td>×</td></tr><tr><td>Repeatable read</td><td>×</td><td>×</td><td>√</td><td>×</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;READ-UNCOMMITTED-未提交读&quot;&gt;&lt;a href=&quot;#READ-UNCOMMITTED-未提交读&quot; class=&quot;headerlink&quot; title=&quot;READ UNCOMMITTED(未提交读)&quot;&gt;&lt;/a&gt;READ UNCOMMITTED(未提交读)
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>为什么String是不可变对象(译)</title>
    <link href="http://yoursite.com/2017/11/23/%E4%B8%BA%E4%BB%80%E4%B9%88String%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1(%E8%AF%91)/"/>
    <id>http://yoursite.com/2017/11/23/为什么String是不可变对象(译)/</id>
    <published>2017-11-23T03:01:23.000Z</published>
    <updated>2018-02-23T03:22:21.787Z</updated>
    
    <content type="html"><![CDATA[<p>原文:<a href="http://www.programcreek.com/2013/04/why-string-is-immutable-in-java/" target="_blank" rel="noopener">Why String is immutable in Java ? </a></p><p><strong>String</strong>是Java中的一个不可变类。所谓不可变，简单来说就是其对象不能被修改。实例中的所有信息在初始化的时候就已经具备，并且不能被修改。不可变类有很多优点。这篇文章简要说明了为什么String被设计为不可变类。关于其好的回答应该建立在对内存模型、同步和数据结构等的理解之上。</p><h1 id="1-字符串池的需求"><a href="#1-字符串池的需求" class="headerlink" title="1. 字符串池的需求"></a>1. 字符串池的需求</h1><p>字符串池是一个位于方法区的特殊区域。当一个字符串被创建的时候，如果该字符串已经存在于字符串池中，那么直接返回该字符串的引用，而不是创建一个新的字符串。<br>下边的代码将只会创建一个字符串对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abcd"</span>;</span><br><span class="line">String s2 = <span class="string">"abcd"</span>;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/String.png" alt=""></p><p>s1和s2都指向同一个字符串对象。<br>如果String不是不可变的，那么修改s1的字符串对象同样也会导致s2的内容发生变化。</p><h1 id="2-缓存Hashcode"><a href="#2-缓存Hashcode" class="headerlink" title="2. 缓存Hashcode"></a>2. 缓存Hashcode</h1><p>字符串的hashcode在Java中经常被用到。例如，在一个HashMap中。其不可变性保证了hashcode（哈希值）总是保持不变，从而不用担心因hashcode变化导致的缓存问题。那就意味着，不用每次在其使用的时候计算其hashcode，从而更加高效。<br>在String类中，有如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">//用来缓存hash code</span></span><br></pre></td></tr></table></figure></p><h1 id="3-简化其他对象的使用"><a href="#3-简化其他对象的使用" class="headerlink" title="3. 简化其他对象的使用"></a>3. 简化其他对象的使用</h1><p>为了理解这一点，请看下边的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();</span><br><span class="line">set.add(new String(&quot;a&quot;));</span><br><span class="line">set.add(new String(&quot;b&quot;));</span><br><span class="line">set.add(new String(&quot;c&quot;));</span><br><span class="line">for (String a : set)</span><br><span class="line">    a.value = &quot;a&quot;;</span><br></pre></td></tr></table></figure></p><p>这个例子中，如果String是可变的，也就是说set中的值是可变的，这会影响到set的设计（set包含不重复的元素）。当然这个例子是有问题的，在String类中是不存在value这个属性的。（ps：个人觉得应该是没有可以直接访问的value，毕竟String中value数组是可以通过反射访问的，不知道，不知道这个老外是怎么个意思）</p><h1 id="4-安全性"><a href="#4-安全性" class="headerlink" title="4.安全性"></a>4.安全性</h1><p>字符串在许多的java类中都用作参数，例如网络连接，打开文件等等。如果字符串是可变的，一个连接或文件就会被修改从而导致严重的错误。可变的字符串也会导致在使用反射时导致严重的问题，因为参数是字符串形式的。<br>举例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSecure(s)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果s内的值被修改，则会导致出现问题</span></span><br><span class="line">    doSomethind(s);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（虽然略牵强，但是也有一定道理）</p><h1 id="5-不可变的对象本身就是线程安全的"><a href="#5-不可变的对象本身就是线程安全的" class="headerlink" title="5. 不可变的对象本身就是线程安全的"></a>5. 不可变的对象本身就是线程安全的</h1><p>不可变的对象，可以在多个线程间自由共享。从而免除了进行同步的麻烦。</p><p>总之， String被设计为不可变的类，是出于性能和安全性的考虑，这也是其他所有不可变类应用的初衷。</p><h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a>6. 引用</h1><blockquote><p><a href="http://blog.csdn.net/get_set/article/details/49926511" target="_blank" rel="noopener">http://blog.csdn.net/get_set/article/details/49926511</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文:&lt;a href=&quot;http://www.programcreek.com/2013/04/why-string-is-immutable-in-java/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why String is immutable 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
