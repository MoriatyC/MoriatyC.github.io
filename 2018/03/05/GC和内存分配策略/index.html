<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="内存调优,gc," />










<meta name="description" content="一. 概述由于程序计数器、虚拟机栈和本地方法栈都是跟线程相关的，栈中的栈帧随着方法的进入和退出进行着出栈和入栈的操作，当方法结束的时候，这部分内存也会跟着回收，所以一般gc讨论的都是方法区和堆。 GC对象的判断1. 引用计数法给对象添加一个计数器，有人引用就加1，引用失效就减1，任何时刻计数器为0的对象就不可能再被使用了。 2. 可达性分析算法判断当前对象与GC Root是否可达 可作为GC Ro">
<meta name="keywords" content="内存调优,gc">
<meta property="og:type" content="article">
<meta property="og:title" content="GC和内存分配策略">
<meta property="og:url" content="http://yoursite.com/2018/03/05/GC和内存分配策略/index.html">
<meta property="og:site_name" content="Be Better">
<meta property="og:description" content="一. 概述由于程序计数器、虚拟机栈和本地方法栈都是跟线程相关的，栈中的栈帧随着方法的进入和退出进行着出栈和入栈的操作，当方法结束的时候，这部分内存也会跟着回收，所以一般gc讨论的都是方法区和堆。 GC对象的判断1. 引用计数法给对象添加一个计数器，有人引用就加1，引用失效就减1，任何时刻计数器为0的对象就不可能再被使用了。 2. 可达性分析算法判断当前对象与GC Root是否可达 可作为GC Ro">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/kedaxingfenxi.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/gc2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/young_gc.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/gc3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/gc1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/serial.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/parnew.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/parallel.png">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/timg.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/g1.png">
<meta property="og:updated_time" content="2018-03-06T01:57:12.150Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GC和内存分配策略">
<meta name="twitter:description" content="一. 概述由于程序计数器、虚拟机栈和本地方法栈都是跟线程相关的，栈中的栈帧随着方法的进入和退出进行着出栈和入栈的操作，当方法结束的时候，这部分内存也会跟着回收，所以一般gc讨论的都是方法区和堆。 GC对象的判断1. 引用计数法给对象添加一个计数器，有人引用就加1，引用失效就减1，任何时刻计数器为0的对象就不可能再被使用了。 2. 可达性分析算法判断当前对象与GC Root是否可达 可作为GC Ro">
<meta name="twitter:image" content="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/kedaxingfenxi.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/05/GC和内存分配策略/"/>





  <title>GC和内存分配策略 | Be Better</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?437ed2136949939c261ae148b39218da";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Be Better</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">厚积薄发</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/GC和内存分配策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MoriatyC">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Be Better">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GC和内存分配策略</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T22:02:22+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/03/05/GC和内存分配策略/" class="leancloud_visitors" data-flag-title="GC和内存分配策略">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>由于程序计数器、虚拟机栈和本地方法栈都是跟线程相关的，栈中的栈帧随着方法的进入和退出进行着出栈和入栈的操作，当方法结束的时候，这部分内存也会跟着回收，所以一般gc讨论的都是方法区和堆。</p>
<h2 id="GC对象的判断"><a href="#GC对象的判断" class="headerlink" title="GC对象的判断"></a>GC对象的判断</h2><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><p>给对象添加一个计数器，有人引用就加1，引用失效就减1，任何时刻计数器为0的对象就不可能再被使用了。</p>
<h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><p>判断当前对象与GC Root是否可达</p>
<p>可作为GC Roots的对象：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(Native方法）引用的对象</li>
</ol>
<p>说的通俗一点就是：方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。在网上看老外说的更具体分成了下面这些：</p>
<ol>
<li>System Class</li>
</ol>
<p>Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .</p>
<ol>
<li>JNI Local</li>
</ol>
<p>Local variable in native code, such as user defined JNI code or JVM internal code.</p>
<ol>
<li>JNI Global</li>
</ol>
<p>Global variable in native code, such as user defined JNI code or JVM internal code.</p>
<ol>
<li>Thread Block</li>
</ol>
<p>Object referred to from a currently active thread block.</p>
<ol>
<li>Thread</li>
</ol>
<p>A started, but not stopped, thread.</p>
<ol>
<li>Busy Monitor</li>
</ol>
<p>Everything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.</p>
<ol>
<li>Java Local</li>
</ol>
<p>Local variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.</p>
<ol>
<li>Native Stack</li>
</ol>
<p>In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.</p>
<ol>
<li>Finalizable</li>
</ol>
<p>An object which is in a queue awaiting its finalizer to be run.</p>
<ol>
<li>Unfinalized</li>
</ol>
<p>An object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.</p>
<ol>
<li>Unreachable</li>
</ol>
<p>An object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.</p>
<ol>
<li>Java Stack Frame</li>
</ol>
<p>A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.</p>
<p>13.Unknown</p>
<p>An object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump.</p>
<h3 id="3-引用的分类"><a href="#3-引用的分类" class="headerlink" title="3. 引用的分类"></a>3. 引用的分类</h3><p>在java1.2之后对引用的概念进行了扩充，有了4种引用</p>
<ol>
<li>强引用：程序代码中普遍存在的类似<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>只要强引用还在，GC就不会回收掉被引用的对象。</p>
<ol>
<li>软引用： 描述一些还有用但是非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果此时内存还不够才会oom</li>
</ol>
<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<ol>
<li>弱引用： 也是描述非必须对象，强度比弱引用还要弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当gc工作无论当时内存是否足够都会回收掉只被弱引用关联的对象。</li>
<li>虚引用： 最弱的引用关系。一个对象是否有虚引用完全不会对其生存周期构成影响，也无法通过虚引用来获取一个对象实例。设置他的目的就是在被GC回收的时候收到一个系统通知</li>
</ol>
<h3 id="4-可达性分析"><a href="#4-可达性分析" class="headerlink" title="4. 可达性分析"></a>4. 可达性分析</h3><p>若一个对象的引用类型有多个，那到底如何判断它的可达性呢？其实规则如下：</p>
<p>单条引用链的可达性以最弱的一个引用类型来决定；<br>多条引用链的可达性以最强的一个引用类型来决定；</p>
<p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/kedaxingfenxi.png" alt=""></p>
<p>我们假设图2中引用①和③为强引用，⑤为软引用，⑦为弱引用，对于对象5按照这两个判断原则，路径①-⑤取最弱的引用⑤，因此该路径对对象5的引用为软引用。同样，③-⑦为弱引用。在这两条路径之间取最强的引用，于是对象5是一个软可及对象</p>
<h3 id="5-回收方法区"><a href="#5-回收方法区" class="headerlink" title="5. 回收方法区"></a>5. 回收方法区</h3><p>废弃常量和无用类的回收</p>
<p>回收废弃常量类似回收对象，比如一个字符串常量，没有被任何String对象使用，如果这时发生了内存回收，而且有必要的话，会被系统清理出常量池</p>
<p>废弃类的判断要同时满足下面3个条件：</p>
<ol>
<li>该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射方位该类的方法</li>
</ol>
<p>在java8中由于永久代的废弃，类信息保存在本地内存中，所以废弃类导致oom溢出的情况得到了很大的改善。</p>
<h1 id="二-垃圾收集算法"><a href="#二-垃圾收集算法" class="headerlink" title="二. 垃圾收集算法"></a>二. 垃圾收集算法</h1><h2 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1. 标记清除算法"></a>1. 标记清除算法</h2><p>对象真正死亡要经历2次标记过程</p>
<ol>
<li>对象在进行可达性分析后，没有与GC ROOTS相连接的引用链，那么它会被第一次标记，并进行一次筛选，筛选条件是此对象是否有必要执行的finalize（）方法。以下是2种没有必要执行finalize（）方法的情形。<ol>
<li>对象没有覆盖finalize（）</li>
<li>finalize（）方法已经被虚拟机调用过。<strong>因为finalize（）方法只会被虚拟机调用一次。</strong></li>
</ol>
</li>
</ol>
<p>如果要执行finalize（）方法，则会将对象加入F——QUEUE的队列中，并且会在稍后由jvm自动建立的、低优先级的Finalizer线程去执行。这里的执行只是会去<strong>触发</strong>这个方法并不能承诺会等待方法运行结束。因为如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环，会导致F-Queue中其他对象处于永久等待，甚至导致整个内存回收系统崩溃。对象可以在finalize（）方法中重新和引用链建立关联，这样就可以逃脱回收。</p>
<ol>
<li>GC对F-Queue中的对象进行第二次小规模的标记。也就是说如果没有执行finalize（）方法进入F-Queue那么直接就被删除了。<h4 id="finalize-是对象逃脱死亡的最后机会，但是finalize-是对c-的妥协，他的运行代价高，不确定性大，使用try——finally能更好的完成他需要执行的工作，所以不推荐使用它。"><a href="#finalize-是对象逃脱死亡的最后机会，但是finalize-是对c-的妥协，他的运行代价高，不确定性大，使用try——finally能更好的完成他需要执行的工作，所以不推荐使用它。" class="headerlink" title="finalize()是对象逃脱死亡的最后机会，但是finalize()是对c++的妥协，他的运行代价高，不确定性大，使用try——finally能更好的完成他需要执行的工作，所以不推荐使用它。"></a>finalize()是对象逃脱死亡的最后机会，但是finalize()是对c++的妥协，他的运行代价高，不确定性大，使用try——finally能更好的完成他需要执行的工作，所以不推荐使用它。</h4></li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>效率问题，标记和清楚2个过程的效率都不高</li>
<li>空间问题，标记清除之后会长生大量的不连续碎片，碎片太多在分配较大对象的时候，无法找到足够的连续内存不得不触发领一次垃圾收集动作</li>
</ol>
<p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/gc2.png" alt=""></p>
<h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h2><h3 id="复制算法-新生代-GC"><a href="#复制算法-新生代-GC" class="headerlink" title="复制算法(新生代 GC)"></a>复制算法(新生代 GC)</h3><p>基于大多数新生对象(98%)都会在GC中被收回的假设。新生代的GC 使用复制算法。</p>
<p>在GC前To 幸存区(survivor)保持清空,对象保存在 Eden 和 From 幸存区(survivor)中，GC运行时,Eden中的幸存对象被复制到 To 幸存区(survivor)。针对 From 幸存区(survivor)中的幸存对象，会考虑对象年龄,如果年龄没达到阀值(tenuring threshold)，对象会被复制到To 幸存区(survivor)。如果达到阀值对象被复制到老年代。复制阶段完成后，Eden 和From 幸存区中只保存死对象，可以视为清空。<strong>如果在复制过程中To 幸存区被填满了，剩余的对象会被复制到老年代中</strong>。最后 From 幸存区和 To幸存区会调换下名字，在下次GC时，To 幸存区会成为From 幸存区。当survivor空间不够的时候会进行分配担保，把对象保存到老年代。</p>
<ul>
<li>优点：运行高效，实现简单</li>
<li>缺点：会浪费一定的内存，对象存活率较高会产生过多的复制</li>
<li><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/young_gc.png" alt=""><br>上图演示GC过程，黄色表示死对象，绿色表示剩余空间，红色表示幸存对象</li>
</ul>
<h2 id="3-标记-整理算法-老年代"><a href="#3-标记-整理算法-老年代" class="headerlink" title="3. 标记-整理算法(老年代)"></a>3. 标记-整理算法(老年代)</h2><p>由于老年代的对象存活时间久，使用复制算法将进行大量复制操作，效率很低，而且其存在时间久，很可能出现大面积的存活对象，这样在极端情况下100%内存的对象都存活，就还需要额外的空间分配担保。</p>
<p>标记-整理算法类似之前的标记清楚算法，但是他不会直接清除可回收对象，而是将存活对象都移动到一段，再直接清理边界以外的内存。<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/gc3.png" alt=""></p>
<h1 id="4-HostSpot的实现"><a href="#4-HostSpot的实现" class="headerlink" title="4. HostSpot的实现"></a>4. HostSpot的实现</h1><h2 id="1-枚举GCRoot"><a href="#1-枚举GCRoot" class="headerlink" title="1. 枚举GCRoot"></a>1. 枚举GCRoot</h2><p>通过OopMap数据结构，在类加载的时候，就把对象内什么偏移量上是什么类型的数据计算出来了。</p>
<h2 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2. 安全点"></a>2. 安全点</h2><p>会导致OopMap内容变化的指令非常多，所以只会在特定的位置记录这些信息，这样的位置称为安全点。 比如：方法调用、循环跳转、异常跳转等。</p>
<p><strong>在这个点, 所有GC Root的状态都是已知并且heap里的对象是一致的; 在这个点进行GC时, 所有的线程都需要block住, 这就是(STW)Stop The World.</strong></p>
<h3 id="在安全点终端所有线程的两种方法"><a href="#在安全点终端所有线程的两种方法" class="headerlink" title="在安全点终端所有线程的两种方法"></a>在安全点终端所有线程的两种方法</h3><ol>
<li>抢先式中断：所有线程中断，如果有的线程不在安全点上就恢复它，让其执行到安全点再中断，但是几乎没有jvm采用这种方式。</li>
<li>主动式中断：在和安全点重合的地方设置一个轮询标志，让线程执行的时候主动去轮询这个标志，如果中断标志为真，就自己中断挂起。<h2 id="3-安全区域safe-region"><a href="#3-安全区域safe-region" class="headerlink" title="3. 安全区域safe region"></a>3. 安全区域safe region</h2>针对于处于Sleep状态或者blocked状态的线程，指的是在一段代码片段之中引用关系不会发生变化，在这片区域的任何地方GC都是安全的。<br>当线程执行到安全区域的时候首先会标识自己进入了安全区域，这样在这段时间内都可以进行gc，当要离开安全区域时，会检查是否已经完成了gcroot的枚举，如果完成了就继续执行，否则就等待。</li>
</ol>
<h1 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h1><p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/gc1.png" alt=""><br>连线代表可搭配使用</p>
<h2 id="1-Serial收集器（Client模式默认新生代收集器，复制算法，单线程）"><a href="#1-Serial收集器（Client模式默认新生代收集器，复制算法，单线程）" class="headerlink" title="1.Serial收集器（Client模式默认新生代收集器，复制算法，单线程）"></a>1.Serial收集器（Client模式默认新生代收集器，复制算法，单线程）</h2><p>在进行垃圾回收的时候，暂停所有正在工作的线程，直到结束。<br>优点：简单高效。<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/serial.png" alt=""></p>
<h2 id="2-ParNew收集器（新生代，复制，多线程）"><a href="#2-ParNew收集器（新生代，复制，多线程）" class="headerlink" title="2. ParNew收集器（新生代，复制，多线程）"></a>2. ParNew收集器（新生代，复制，多线程）</h2><p>ParNew就是Serial的多线程版本，除了多线程外几乎一致。Server模式下的首选新生代收集器，只有他和Serial能和cms配合。使用-XX:+UseParNewGC开关来控制，使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</p>
<p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/parnew.png" alt=""></p>
<h2 id="3-Parallel-Scavenge收集器（新生代，复制-多线程-吞吐量优先）"><a href="#3-Parallel-Scavenge收集器（新生代，复制-多线程-吞吐量优先）" class="headerlink" title="3. Parallel Scavenge收集器（新生代，复制,多线程,吞吐量优先）"></a>3. Parallel Scavenge收集器（新生代，复制,多线程,吞吐量优先）</h2><p>吞吐量=运行用户代码时间/(运行用户代码时间+gc时间)</p>
<p>Parallel Scavenge收集器不像别的收集器关注的是减少用户停顿时间，而是吞吐量。</p>
<p>-XX:+UseParallelGC开关控制</p>
<p>-XX：MaxGCPauseMillis控制最大gc停顿时间</p>
<p>-XX:GCTimeRatio设置吞吐量</p>
<p>-XX:+UseAdaptiveSizePolicy,自动的动态调整停顿时间和吞吐量，GC的自适应调节策略，适合新手。</p>
<h2 id="4-Serial-Old收集器（老年代，标记-整理，单线程）"><a href="#4-Serial-Old收集器（老年代，标记-整理，单线程）" class="headerlink" title="4. Serial Old收集器（老年代，标记-整理，单线程）"></a>4. Serial Old收集器（老年代，标记-整理，单线程）</h2><p>是Serial收集器的老年代版本</p>
<p>1.5之前和Parallel Scavenge搭配使用或者作为cms的备案</p>
<h2 id="5-Parallel-Old收集器（老年代，-标记-整理，多线程）"><a href="#5-Parallel-Old收集器（老年代，-标记-整理，多线程）" class="headerlink" title="5. Parallel Old收集器（老年代， 标记-整理，多线程）"></a>5. Parallel Old收集器（老年代， 标记-整理，多线程）</h2><p>Parallel Scavenge的老年代版本，适合注重吞吐量和cpu资源敏感的场合<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/parallel.png" alt=""></p>
<h2 id="6-CMS收集器（老年代，标记-清理，多线程）"><a href="#6-CMS收集器（老年代，标记-清理，多线程）" class="headerlink" title="6. CMS收集器（老年代，标记-清理，多线程）"></a>6. CMS收集器（老年代，标记-清理，多线程）</h2><p>以获取最短回收停顿时间为目标的收集器。</p>
<p>过程：</p>
<ol>
<li>初始标记：标记一下GCROOT能关联到的对象<strong>stw</strong></li>
<li>并发标记：GCROOT Tracing</li>
<li>重新标记：修正并发标记期间产生变动的引用<strong>stw</strong></li>
<li>并发清除<br><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/timg.jpg" alt=""><br>在初始标记和重新标记的时候需要stop the world</li>
</ol>
<p>优点：</p>
<p>并行，停顿小。</p>
<p>缺点：</p>
<ol>
<li>cpu资源敏感：<br> 因为并发导致吞吐量降低，随着cpu数量的下降对程序影响越大</li>
<li><p>无法处理浮动垃圾：<br> 因为并发清理是并发执行的，所以此时还是会产生心的垃圾，称之为浮动垃圾。这部分垃圾只能等待下一次的GC。</p>
<p> 这里产生一个问题就是老年代不能等到完全的利用，需要一部分用来存储浮动垃圾，如果预留的内存无法满足需要就会产生“ConcurrentModeFailure”，这是会启用Serial Old收集器进行gc。</p>
</li>
<li>使用标记-清除算法产生大量内存碎片</li>
</ol>
<h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h2><p>特点：</p>
<ol>
<li>缩短stop the world停顿时间，通过并发的方式将停顿并发执行从而取消停顿。</li>
<li>分代收集，不需要其他收集器单独管理整个gc堆，采用不同方式处理新对象和老对象</li>
<li>不会产生碎片。</li>
<li>可预测的停顿</li>
</ol>
<p>G1收集的范围是整个新生代和老年代，但是他是将整个堆划分为多个大小相等的独立区域（Region），它会优先回收价值最大的Region，保证在有限时间获取最高的收集效率。根据用户所期望的GC停顿时间来指定回收计划。</p>
<ol>
<li>初始标记</li>
</ol>
<p>标记GC ROOTs能直接关联到的对象，耗时短</p>
<ol>
<li>并发标记</li>
</ol>
<p>可达性分析，耗时长，但是可以和用户线程并发</p>
<ol>
<li>最终标记</li>
</ol>
<p>需要停顿，但是可以并行执行</p>
<ol>
<li>筛选回收</li>
</ol>
<p>对回收价值和成本进行排序</p>
<p>其他收集器的范围都是整个新生代或者老年代，G1自己管理整个，他将heap的内存布局划分成多个大小相等的独立区域(region)，虽然还保留新生代和老年代的概念。</p>
<blockquote>
<p>垃圾堆积的价值：回收所获得的空间大小以及回收所需时间的经验值的关系<br>维护一个优先队列，优先回收价值最大的region</p>
</blockquote>
<h3 id="g1和cms区别"><a href="#g1和cms区别" class="headerlink" title="g1和cms区别"></a>g1和cms区别</h3><p>CMS收集器：是基于标记清除算法实现的，一般就是初始标记，并发标记，重新标记，并发清除，目的是实现最短的响应回收时间。保证系统的响应时间，减少垃圾收集时的停顿时间<br>G1收集器：他的过程是初始标记、并发标记、最终标记、筛选回收，基于标记整理算法实现，以吞吐量优先，保证保证吞吐量的。</p>
<p><img src="https://raw.githubusercontent.com/MoriatyC/MoriatyC.github.io/master/images/g1.png" alt=""></p>
<h1 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h1><h3 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h3><p>为了优化垃圾回收的性能，将堆分为了新生代和老年代</p>
<p>优点：</p>
<ol>
<li>是简化了新生对象的分配（只在新生代分配内存），</li>
<li>是可以针对不同区域使用更有效的垃圾回收算法。</li>
<li><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4>通过广泛研究面向对象实现的应用，发现一个共同特点：很多对象的生存时间都很短。同时研究发现，新生对象很少引用生存时间长的对象。结合这2个特点，很明显 <strong>GC 会频繁访问新生对象</strong>。在新生代中，GC可以快速标记回收”死对象”，而不需要扫描整个Heap中的存活一段时间的”老对象”。</li>
</ol>
<p>SUN/Oracle 的HotSpot JVM 又把新生代进一步划分为3个区域：一个相对大点的区域，称为”伊甸园区(Eden)”；两个相对小点的区域称为”From 幸存区(survivor)”和”To 幸存区(survivor)”。按照规定,新对象会首先分配在 Eden 中(<strong>如果新对象过大，会直接分配在老年代中</strong>)。在GC中，Eden 中的对象会被移动到survivor中，直至对象满足一定的年纪(定义为熬过GC的次数),会被移动到老年代。</p>
<ul>
<li>新生代GC(Minor GC):发生在新生代的垃圾收集动作，频繁，回收速度快</li>
<li>老年代GC(Full GC/ Major GC)：发生在老年代的GC，一般比Minor GC慢10倍<h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2>当Eden不够时，发起一次Minor GC<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2>比如很长的数组和字符串</li>
</ul>
<p>—XX：PretenureSizeThreshold参数，零大于这个值的对象直接在老年代分配</p>
<h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>经过一次Minor GC后存活进入Survivor的对象设置为1岁，每经过1次Minor GC加一岁，达到一定岁数进入老年代。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>survivor空间中相同年龄所有对象大小的总和大于单个survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在Minor Gc前检查老年代的连续空间大于新生代对象总大小，if （true）则这次Minor GC是安全的。</p>
<p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会尽心Minor GC 否则 full GC。</p>
<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><blockquote>
<p><a href="http://ifeve.com/useful-jvm-flags-part-5-young-generation-garbage-collection/" target="_blank" rel="noopener">http://ifeve.com/useful-jvm-flags-part-5-young-generation-garbage-collection/</a></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/内存调优/" rel="tag"># 内存调优</a>
          
            <a href="/tags/gc/" rel="tag"># gc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/04/java内存区域/" rel="next" title="java内存区域">
                <i class="fa fa-chevron-left"></i> java内存区域
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/06/类加载机制/" rel="prev" title="类加载机制">
                类加载机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzAzNS85NTk3"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">MoriatyC</p>
              <p class="site-description motion-element" itemprop="description">MoriatyC的学习心得</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/pages/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-概述"><span class="nav-number">1.</span> <span class="nav-text">一. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GC对象的判断"><span class="nav-number">1.1.</span> <span class="nav-text">GC对象的判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-引用计数法"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-可达性分析算法"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-引用的分类"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 引用的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-可达性分析"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 可达性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-回收方法区"><span class="nav-number">1.1.5.</span> <span class="nav-text">5. 回收方法区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-垃圾收集算法"><span class="nav-number">2.</span> <span class="nav-text">二. 垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-标记清除算法"><span class="nav-number">2.1.</span> <span class="nav-text">1. 标记清除算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize-是对象逃脱死亡的最后机会，但是finalize-是对c-的妥协，他的运行代价高，不确定性大，使用try——finally能更好的完成他需要执行的工作，所以不推荐使用它。"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">finalize()是对象逃脱死亡的最后机会，但是finalize()是对c++的妥协，他的运行代价高，不确定性大，使用try——finally能更好的完成他需要执行的工作，所以不推荐使用它。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点："><span class="nav-number">2.1.1.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-复制算法"><span class="nav-number">2.2.</span> <span class="nav-text">2. 复制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法-新生代-GC"><span class="nav-number">2.2.1.</span> <span class="nav-text">复制算法(新生代 GC)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-标记-整理算法-老年代"><span class="nav-number">2.3.</span> <span class="nav-text">3. 标记-整理算法(老年代)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-HostSpot的实现"><span class="nav-number">3.</span> <span class="nav-text">4. HostSpot的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-枚举GCRoot"><span class="nav-number">3.1.</span> <span class="nav-text">1. 枚举GCRoot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-安全点"><span class="nav-number">3.2.</span> <span class="nav-text">2. 安全点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在安全点终端所有线程的两种方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">在安全点终端所有线程的两种方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-安全区域safe-region"><span class="nav-number">3.3.</span> <span class="nav-text">3. 安全区域safe region</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-垃圾收集器"><span class="nav-number">4.</span> <span class="nav-text">5. 垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Serial收集器（Client模式默认新生代收集器，复制算法，单线程）"><span class="nav-number">4.1.</span> <span class="nav-text">1.Serial收集器（Client模式默认新生代收集器，复制算法，单线程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ParNew收集器（新生代，复制，多线程）"><span class="nav-number">4.2.</span> <span class="nav-text">2. ParNew收集器（新生代，复制，多线程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Parallel-Scavenge收集器（新生代，复制-多线程-吞吐量优先）"><span class="nav-number">4.3.</span> <span class="nav-text">3. Parallel Scavenge收集器（新生代，复制,多线程,吞吐量优先）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Serial-Old收集器（老年代，标记-整理，单线程）"><span class="nav-number">4.4.</span> <span class="nav-text">4. Serial Old收集器（老年代，标记-整理，单线程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Parallel-Old收集器（老年代，-标记-整理，多线程）"><span class="nav-number">4.5.</span> <span class="nav-text">5. Parallel Old收集器（老年代， 标记-整理，多线程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-CMS收集器（老年代，标记-清理，多线程）"><span class="nav-number">4.6.</span> <span class="nav-text">6. CMS收集器（老年代，标记-清理，多线程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-G1收集器"><span class="nav-number">4.7.</span> <span class="nav-text">7. G1收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#g1和cms区别"><span class="nav-number">4.7.1.</span> <span class="nav-text">g1和cms区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存分配机制"><span class="nav-number">5.</span> <span class="nav-text">内存分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新生代与老年代"><span class="nav-number">5.0.1.</span> <span class="nav-text">新生代与老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">新生代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象优先在Eden分配"><span class="nav-number">5.1.</span> <span class="nav-text">对象优先在Eden分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大对象直接进入老年代"><span class="nav-number">5.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#长期存活的对象进入老年代"><span class="nav-number">5.3.</span> <span class="nav-text">长期存活的对象进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态对象年龄判定"><span class="nav-number">5.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间分配担保"><span class="nav-number">5.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考地址"><span class="nav-number">6.</span> <span class="nav-text">参考地址</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MoriatyC</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("OIGC8k9baipUzVfovuOOtbMN-gzGzoHsz", "OsMH9m7h8SIr5IoxhIDi6Ahk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
